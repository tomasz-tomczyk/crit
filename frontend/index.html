<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crit</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
/* ===== CSS Reset & Variables ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --font-body: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
  /* Dark values in :root = fallback when prefers-color-scheme is unsupported */
  --bg-primary: #1a1b26;
  --bg-secondary: #16171f;
  --bg-tertiary: #262940;
  --bg-hover: #2d3150;
  --bg-gutter: #131420;
  --fg-primary: #c0caf5;
  --fg-secondary: #a9b1d6;
  --fg-muted: #565f89;
  --fg-dimmed: #4a5275;
  --accent: #7aa2f7;
  --accent-hover: #89b4fa;
  --accent-subtle: rgba(122, 162, 247, 0.1);
  --accent-bg: rgba(122, 162, 247, 0.15);
  --green: #9ece6a;
  --red: #f7768e;
  --orange: #ff9e64;
  --yellow: #e0af68;
  --border: #292e42;
  --border-comment: #3d59a1;
  --comment-bg: #1a1f36;
  --selection-bg: rgba(122, 162, 247, 0.08);
  --shadow: 0 2px 8px rgba(0,0,0,0.3);
  --code-bg: #1e2030;
  --table-stripe: rgba(122, 162, 247, 0.04);
  --blockquote-border: #3d59a1;
  --blockquote-bg: rgba(61, 89, 161, 0.08);
  --scrollbar-bg: #1a1b26;
  --scrollbar-thumb: #3b4261;
}

/* System preference: light — overrides dark :root defaults when OS is light */
@media (prefers-color-scheme: light) {
  html:not([data-theme]) {
    --bg-primary: #fafafa;
    --bg-secondary: #f5f5f5;
    --bg-tertiary: #eeeeee;
    --bg-hover: #e8e8e8;
    --bg-gutter: #f0f0f0;
    --fg-primary: #24292f;
    --fg-secondary: #57606a;
    --fg-muted: #8b949e;
    --fg-dimmed: #c0c8d0;
    --accent: #0969da;
    --accent-hover: #0550ae;
    --accent-subtle: rgba(9, 105, 218, 0.08);
    --accent-bg: rgba(9, 105, 218, 0.12);
    --green: #1a7f37;
    --red: #cf222e;
    --orange: #bc4c00;
    --yellow: #9a6700;
    --border: #d8dee4;
    --border-comment: #0969da;
    --comment-bg: #f0f6ff;
    --selection-bg: rgba(9, 105, 218, 0.06);
    --shadow: 0 2px 8px rgba(0,0,0,0.08);
    --code-bg: #f5f5f5;
    --table-stripe: rgba(0, 0, 0, 0.02);
    --blockquote-border: #0969da;
    --blockquote-bg: rgba(9, 105, 218, 0.04);
    --scrollbar-bg: #fafafa;
    --scrollbar-thumb: #d0d0d0;
  }
}

[data-theme="dark"] {
  --bg-primary: #1a1b26;
  --bg-secondary: #16171f;
  --bg-tertiary: #262940;
  --bg-hover: #2d3150;
  --bg-gutter: #131420;
  --fg-primary: #c0caf5;
  --fg-secondary: #a9b1d6;
  --fg-muted: #565f89;
  --fg-dimmed: #4a5275;
  --accent: #7aa2f7;
  --accent-hover: #89b4fa;
  --accent-subtle: rgba(122, 162, 247, 0.1);
  --accent-bg: rgba(122, 162, 247, 0.15);
  --green: #9ece6a;
  --red: #f7768e;
  --orange: #ff9e64;
  --yellow: #e0af68;
  --border: #292e42;
  --border-comment: #3d59a1;
  --comment-bg: #1a1f36;
  --selection-bg: rgba(122, 162, 247, 0.08);
  --shadow: 0 2px 8px rgba(0,0,0,0.3);
  --code-bg: #1e2030;
  --table-stripe: rgba(122, 162, 247, 0.04);
  --blockquote-border: #3d59a1;
  --blockquote-bg: rgba(61, 89, 161, 0.08);
  --scrollbar-bg: #1a1b26;
  --scrollbar-thumb: #3b4261;
}

[data-theme="light"] {
  --bg-primary: #fafafa;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #eeeeee;
  --bg-hover: #e8e8e8;
  --bg-gutter: #f0f0f0;
  --fg-primary: #24292f;
  --fg-secondary: #57606a;
  --fg-muted: #8b949e;
  --fg-dimmed: #c0c8d0;
  --accent: #0969da;
  --accent-hover: #0550ae;
  --accent-subtle: rgba(9, 105, 218, 0.08);
  --accent-bg: rgba(9, 105, 218, 0.12);
  --green: #1a7f37;
  --red: #cf222e;
  --orange: #bc4c00;
  --yellow: #9a6700;
  --border: #d8dee4;
  --border-comment: #0969da;
  --comment-bg: #f0f6ff;
  --selection-bg: rgba(9, 105, 218, 0.06);
  --shadow: 0 2px 8px rgba(0,0,0,0.08);
  --code-bg: #f5f5f5;
  --table-stripe: rgba(0, 0, 0, 0.02);
  --blockquote-border: #0969da;
  --blockquote-bg: rgba(9, 105, 218, 0.04);
  --scrollbar-bg: #fafafa;
  --scrollbar-thumb: #d0d0d0;
}

/* ===== Base ===== */
html {
  font-size: 16px;
  scroll-behavior: smooth;
}

body {
  font-family: var(--font-body);
  background: var(--bg-primary);
  color: var(--fg-primary);
  line-height: 1.7;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* ===== Scrollbar ===== */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: var(--scrollbar-bg); }
::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-muted); }

/* ===== Header ===== */
.header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  padding: 12px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  backdrop-filter: blur(8px);
}

.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.header-title {
  font-size: 15px;
  font-weight: 700;
  color: var(--fg-primary);
  letter-spacing: -0.02em;
}

.header-filename {
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--fg-muted);
  background: var(--bg-tertiary);
  padding: 3px 10px;
  border-radius: 4px;
}

.header-notify {
  font-size: 12px;
  font-weight: 500;
  color: var(--green);
}

.header-update {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  color: var(--fg-muted);
}
.header-update a {
  color: var(--accent);
  text-decoration: none;
}
.header-update a:hover {
  text-decoration: underline;
}
.header-update-dismiss {
  background: none;
  border: none;
  cursor: pointer;
  color: var(--fg-muted);
  font-size: 11px;
  padding: 0 2px;
  line-height: 1;
}
.header-update-dismiss:hover {
  color: var(--fg-primary);
}

.header-right {
  display: flex;
  align-items: center;
  gap: 10px;
}

.comment-count {
  font-size: 13px;
  color: var(--fg-muted);
  font-weight: 500;
}
.comment-count strong {
  color: var(--accent);
}

.btn {
  font-family: var(--font-body);
  font-size: 13px;
  font-weight: 500;
  padding: 6px 14px;
  border: 1px solid var(--border);
  border-radius: 6px;
  cursor: pointer;
  background: var(--bg-tertiary);
  color: var(--fg-primary);
  transition: all 0.15s;
}
.btn:hover { background: var(--bg-hover); }
.btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 1px; }

.btn-primary {
  background: #5b8def;
  color: #fff;
  border-color: #5b8def;
  box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}
.btn-primary:hover { background: #6e9af2; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }

.btn-danger {
  color: var(--red);
  border-color: var(--red);
  background: transparent;
}
.btn-danger:hover { background: rgba(247, 118, 142, 0.1); }

.btn-sm {
  font-size: 12px;
  padding: 3px 10px;
}

.theme-toggle {
  background: none;
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 5px 8px;
  cursor: pointer;
  color: var(--fg-muted);
  font-size: 16px;
  line-height: 1;
  transition: all 0.15s;
}
.theme-toggle:hover { color: var(--fg-primary); background: var(--bg-tertiary); }

/* Three-button theme pill (system / light / dark) */
.theme-pill {
  position: relative;
  display: inline-flex;
  align-items: center;
  border: 1px solid var(--border);
  background: var(--bg-tertiary);
  border-radius: 9999px;
}
.theme-pill-indicator {
  position: absolute;
  width: 33.333%;
  height: 100%;
  border-radius: 9999px;
  background: var(--bg-hover);
  border: 1px solid var(--border);
  left: 0;
  transition: left 0.15s ease;
  pointer-events: none;
}
html[data-theme="light"] .theme-pill-indicator { left: 33.333%; }
html[data-theme="dark"]  .theme-pill-indicator { left: 66.666%; }
.theme-pill-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  padding: 5px 0;
  cursor: pointer;
  background: none;
  border: none;
  color: var(--fg-muted);
  position: relative;
  z-index: 1;
  transition: color 0.15s;
}
.theme-pill-btn:hover { color: var(--fg-primary); }
.theme-pill-btn:focus-visible { outline: 2px solid var(--accent); outline-offset: -1px; border-radius: 9999px; }
html:not([data-theme])  .theme-pill-btn[data-for-theme="system"],
html[data-theme="light"] .theme-pill-btn[data-for-theme="light"],
html[data-theme="dark"]  .theme-pill-btn[data-for-theme="dark"] { color: var(--accent); }
.theme-pill-btn svg { width: 14px; height: 14px; display: block; }

/* ===== Toast Notifications ===== */
.toast-container {
  position: fixed;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  width: min(720px, calc(100vw - 32px));
  pointer-events: none;
}
.toast {
  padding: 10px 16px;
  border-radius: 10px;
  font-size: 13px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  pointer-events: auto;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255,255,255,0.04);
  animation: toast-in 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
.toast.toast-out {
  animation: toast-out 0.2s cubic-bezier(0.4, 0, 1, 1) forwards;
}
@keyframes toast-in {
  from { opacity: 0; transform: translateY(-8px) scale(0.98); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes toast-out {
  from { opacity: 1; transform: translateY(0) scale(1); }
  to { opacity: 0; transform: translateY(-8px) scale(0.98); }
}
.bottom-toast-container {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  pointer-events: none;
}
.bottom-toast-container .toast {
  animation: bottom-toast-in 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
.bottom-toast-container .toast.toast-out {
  animation: bottom-toast-out 0.2s cubic-bezier(0.4, 0, 1, 1) forwards;
}
@keyframes bottom-toast-in {
  from { opacity: 0; transform: translateY(8px) scale(0.98); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes bottom-toast-out {
  from { opacity: 1; transform: translateY(0) scale(1); }
  to { opacity: 0; transform: translateY(8px) scale(0.98); }
}
.toast.warning {
  background: rgba(255, 158, 100, 0.14);
  border: 1px solid rgba(255, 158, 100, 0.3);
  color: var(--orange);
}
.toast.success {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--fg-secondary);
}
.toast.error {
  background: rgba(247, 118, 142, 0.14);
  border: 1px solid rgba(247, 118, 142, 0.3);
  color: var(--red);
}
.toast-btn {
  font-family: var(--font-body);
  font-size: 12px;
  font-weight: 500;
  white-space: nowrap;
  padding: 4px 10px;
  border-radius: 5px;
  border: none;
  cursor: pointer;
  transition: background 0.15s;
}
.toast-btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 1px; }
.toast-btn-ghost {
  background: transparent;
  color: inherit;
  opacity: 0.7;
}
.toast-btn-ghost:hover { opacity: 1; background: rgba(255,255,255,0.06); }
.toast-btn-filled {
  color: var(--bg-primary);
}
.toast.warning .toast-btn-filled {
  background: var(--orange);
}
.toast.warning .toast-btn-filled:hover { filter: brightness(1.1); }
.toast.success .toast-btn-filled {
  background: var(--green);
}
.toast.success .toast-btn-filled:hover { filter: brightness(1.1); }
.toast.error .toast-btn-filled {
  background: var(--red);
}
.toast.error .toast-btn-filled:hover { filter: brightness(1.1); }
.toast-btn-danger {
  background: transparent;
  color: var(--red);
}
.toast-btn-danger:hover { background: rgba(247, 118, 142, 0.12); }
.toast-url {
  font-family: var(--font-mono);
  font-size: 12px;
  word-break: break-all;
  background: rgba(0, 0, 0, 0.15);
  padding: 2px 8px;
  border-radius: 4px;
  margin-left: 4px;
}
.toast-actions { display: flex; gap: 6px; flex-shrink: 0; }

.btn-success {
  color: var(--green);
  border-color: var(--green);
  background: transparent;
}
.btn-success:hover { background: rgba(158, 206, 106, 0.1); }

/* ===== Document Container ===== */
.document-wrapper {
  max-width: 840px;
  margin: 0 auto;
  padding: 32px 0 120px 0;
}

/* ===== Line Blocks ===== */
.line-block {
  position: relative;
  display: flex;
  border-left: 3px solid transparent;
  transition: border-color 0.15s;
}

.line-block:hover {
  background: var(--selection-bg);
}

.line-block.has-comment {
  border-left-color: var(--accent);
}

.line-block.selected {
  background: var(--accent-subtle);
}

.line-block.focused {
  border-left-color: var(--accent);
}
.line-block.focused .line-gutter {
  background: var(--accent-subtle);
}

/* ===== Gutter ===== */
.line-gutter {
  position: relative;
  min-width: 52px;
  padding: 0 8px 0 8px;
  text-align: right;
  font-family: var(--font-mono);
  font-size: 12px;
  line-height: inherit;
  color: var(--fg-dimmed);
  user-select: none;
  cursor: pointer;
  flex-shrink: 0;
  display: flex;
  align-items: flex-start;
  justify-content: flex-end;
}

.line-gutter:hover .line-num { opacity: 0; }
.line-gutter:hover .line-add { opacity: 1; pointer-events: auto; }

/* During drag, show + on all gutters in range */
body.dragging { user-select: none; cursor: grabbing; }
body.dragging .line-block.selected .line-gutter .line-num { opacity: 0; }
body.dragging .line-block.selected .line-gutter .line-add { opacity: 1; pointer-events: auto; }

.line-num {
  padding-top: 1px;
  line-height: inherit;
}

.line-add {
  position: absolute;
  top: 1px;
  right: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 20px;
  height: 20px;
  border-radius: 4px;
  background: var(--accent);
  color: #fff;
  font-size: 14px;
  font-weight: 700;
  line-height: 1;
  opacity: 0;
  pointer-events: none;
}

/* ===== Line Content (rendered markdown) ===== */
.line-content {
  flex: 1;
  min-width: 0;
  padding: 0 24px 0 12px;
  overflow-wrap: break-word;
}

/* ===== Markdown Styles ===== */
.line-content h1,
.line-content h2,
.line-content h3,
.line-content h4,
.line-content h5,
.line-content h6 {
  color: var(--fg-primary);
  font-weight: 600;
  line-height: 1.3;
  margin-top: 8px;
}

.line-content h1 { font-size: 1.8rem; padding-bottom: 8px; border-bottom: 1px solid var(--border); margin-bottom: 4px; }
.line-content h2 { font-size: 1.45rem; padding-bottom: 6px; border-bottom: 1px solid var(--border); margin-bottom: 4px; }
.line-content h3 { font-size: 1.2rem; }
.line-content h4 { font-size: 1.05rem; }
.line-content h5 { font-size: 0.95rem; color: var(--fg-secondary); }
.line-content h6 { font-size: 0.9rem; color: var(--fg-muted); }

.line-content p {
  margin: 4px 0;
}

.line-content a {
  color: var(--accent);
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: border-color 0.15s;
}
.line-content a:hover { border-bottom-color: var(--accent); }

.line-content code {
  font-family: var(--font-mono);
  font-size: 0.88em;
  background: var(--code-bg);
  padding: 2px 6px;
  border-radius: 4px;
  border: 1px solid var(--border);
}

.line-content pre {
  margin: 6px 0;
  padding: 16px;
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow-x: auto;
  line-height: 1.5;
}

.line-content pre code {
  background: none;
  border: none;
  padding: 0;
  font-size: 0.875rem;
}

/* === Per-line code blocks === */
.line-content.code-line {
  background: var(--code-bg);
  font-family: var(--font-mono);
  font-size: 0.875rem;
  line-height: 1.5;
  padding-left: 16px;
  padding-right: 16px;
  border-left: 1px solid var(--border);
  border-right: 1px solid var(--border);
  overflow-x: auto;
  white-space: pre;
}
.line-content.code-line code {
  background: none;
  border: none;
  padding: 0;
  font-size: inherit;
}
.line-content.code-first {
  border-top: 1px solid var(--border);
  border-top-left-radius: 8px;
  border-top-right-radius: 8px;
  padding-top: 8px;
  margin-top: 6px;
}
.line-content.code-last {
  border-bottom: 1px solid var(--border);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  padding-bottom: 8px;
  margin-bottom: 6px;
}
.fence-marker {
  color: var(--fg-dimmed);
  font-size: 0.8rem;
}

/* ===== Mermaid Diagrams ===== */
.line-content.mermaid-block {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px;
  margin: 6px 0;
  text-align: center;
  min-height: 60px;
}
.mermaid-rendered svg {
  max-width: 100%;
  height: auto;
}

/* ===== Images ===== */
.line-content img {
  max-width: 100%;
  height: auto;
  border-radius: 6px;
  margin: 4px 0;
}

/* === Per-row table blocks === */
.line-content.table-row table.split-table {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
  font-size: 0.925rem;
  margin: 0;
}
.line-content.table-row th {
  text-align: left;
  font-weight: 600;
  padding: 10px 14px;
  color: var(--fg-secondary);
  border-bottom: 2px solid var(--border);
}
.line-content.table-row td {
  padding: 8px 14px;
  border-bottom: 1px solid var(--border);
}
.line-content.table-even td {
  background: var(--table-stripe);
}
.line-content.table-first {
  border-top: 1px solid var(--border);
  border-top-left-radius: 8px;
  border-top-right-radius: 8px;
  overflow: hidden;
}
.line-content.table-last {
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  overflow: hidden;
}
.line-content.table-last td {
  border-bottom: none;
}
.line-content.table-separator {
  height: 0;
  padding: 0;
  overflow: hidden;
}
.line-block:has(.table-separator) {
  height: 0;
  overflow: hidden;
  min-height: 0;
}

.line-content blockquote {
  margin: 6px 0;
  padding: 8px 16px;
  border-left: 3px solid var(--blockquote-border);
  background: var(--blockquote-bg);
  border-radius: 0 6px 6px 0;
  color: var(--fg-secondary);
}

.line-content blockquote p {
  margin: 2px 0;
}

.line-content ul,
.line-content ol {
  padding-left: 24px;
  margin: 0;
}

.line-content li {
  margin: 0;
}

.line-content li::marker {
  color: var(--fg-muted);
}

.line-content ul li {
  list-style-type: '  \2022  ';
}

.line-content table {
  width: 100%;
  border-collapse: collapse;
  margin: 8px 0;
  font-size: 0.925rem;
}

.line-content th {
  text-align: left;
  font-weight: 600;
  padding: 10px 14px;
  border-bottom: 2px solid var(--border);
  color: var(--fg-secondary);
}

.line-content td {
  padding: 8px 14px;
  border-bottom: 1px solid var(--border);
}

.line-content tr:nth-child(even) td {
  background: var(--table-stripe);
}

.line-content hr {
  border: none;
  height: 1px;
  background: var(--border);
  margin: 24px 0;
}

.line-content img {
  max-width: 100%;
  border-radius: 6px;
}

/* Task lists */
.line-content .task-list-item {
  list-style: none;
  margin-left: -24px;
  padding-left: 4px;
}

.line-content .task-list-item input[type="checkbox"] {
  margin-right: 8px;
  accent-color: var(--accent);
  transform: scale(1.1);
  pointer-events: none;
}

.line-content strong { font-weight: 600; }
.line-content em { font-style: italic; color: var(--fg-secondary); }

/* Empty lines */
.line-content.empty-line {
  min-height: 1.7em;
}

/* ===== Comment Inline Box (displayed after submission) ===== */
.comment-block {
  max-width: 840px;
  margin: 0 auto;
  padding: 0 0 0 55px;
}

.comment-card {
  margin: 6px 0;
  border: 1px solid var(--border-comment);
  border-radius: 8px;
  background: var(--comment-bg);
  overflow: hidden;
}

.comment-card.carried-forward {
  border-color: var(--orange);
}
.carried-forward-label {
  font-size: 11px;
  color: var(--orange);
  font-weight: 500;
}

.comment-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 14px;
  background: var(--accent-subtle);
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  color: var(--fg-muted);
}

.comment-line-ref {
  font-weight: 600;
  color: var(--accent);
  font-family: var(--font-mono);
}

.comment-actions {
  display: flex;
  gap: 6px;
}

.comment-actions button {
  background: none;
  border: none;
  color: var(--fg-muted);
  cursor: pointer;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 3px;
  transition: all 0.15s;
}
.comment-actions button:hover { color: var(--fg-primary); background: var(--bg-hover); }
.comment-actions .delete-btn:hover { color: var(--red); }

.comment-body {
  padding: 10px 14px;
  font-size: 14px;
  line-height: 1.6;
  word-break: break-word;
}
.comment-body p { margin: 0 0 0.5em 0; }
.comment-body p:last-child { margin-bottom: 0; }
.comment-body code {
  background: var(--bg-tertiary);
  padding: 1px 5px;
  border-radius: 3px;
  font-size: 0.9em;
}
.comment-body pre {
  background: var(--bg-tertiary);
  padding: 8px 10px;
  border-radius: 4px;
  overflow-x: auto;
  margin: 0.5em 0;
}
.comment-body pre code { background: none; padding: 0; }
.comment-body ul, .comment-body ol { margin: 0.3em 0; padding-left: 1.5em; }
.comment-body a {
  color: var(--accent);
  text-decoration: none;
  border-bottom: 1px solid var(--accent-subtle);
  transition: color 0.15s, border-color 0.15s;
}
.comment-body a:hover {
  color: var(--accent-hover);
  border-bottom-color: var(--accent-hover);
}
.comment-body blockquote {
  border-left: 3px solid var(--border);
  margin: 0.5em 0;
  padding-left: 10px;
  color: var(--fg-secondary);
}

.comment-time {
  font-size: 11px;
  color: var(--fg-dimmed);
}

/* ===== Resolved Comments ===== */
.resolved-comment {
  max-width: 840px;
  margin: 4px auto 4px 48px;
  padding: 6px 12px;
  background: var(--bg-secondary);
  border-left: 3px solid var(--green);
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.resolved-comment:hover {
  background: var(--bg-hover);
}
.resolved-comment-header {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  min-width: 0;
}
.resolved-comment .resolved-check {
  color: var(--green);
  font-weight: 600;
  flex-shrink: 0;
}
.resolved-comment .resolved-body {
  color: var(--fg-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}
.resolved-comment .resolved-note {
  font-style: italic;
  color: var(--fg-muted);
  padding-left: 20px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.resolved-comment.expanded .resolved-body,
.resolved-comment.expanded .resolved-note {
  white-space: normal;
  overflow: visible;
}

/* ===== Comment Input Form ===== */
.comment-form-wrapper {
  max-width: 840px;
  margin: 0 auto;
  padding: 0 0 0 55px;
}

.comment-form {
  margin: 6px 0;
  border: 1px solid var(--accent);
  border-radius: 8px;
  background: var(--comment-bg);
  overflow: hidden;
  box-shadow: 0 0 0 2px var(--accent-subtle);
}

.comment-form-header {
  padding: 8px 14px;
  font-size: 12px;
  font-weight: 600;
  color: var(--accent);
  font-family: var(--font-mono);
  background: var(--accent-subtle);
  border-bottom: 1px solid var(--border);
}

.comment-form textarea {
  display: block;
  width: 100%;
  min-height: 80px;
  padding: 10px 14px;
  border: none;
  background: var(--comment-bg);
  color: var(--fg-primary);
  font-family: var(--font-body);
  font-size: 14px;
  line-height: 1.6;
  resize: none;
  field-sizing: content;
  outline: none;
}

.comment-form textarea::placeholder {
  color: var(--fg-dimmed);
}

.comment-form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  padding: 8px 14px;
  border-top: 1px solid var(--border);
}


/* ===== Waiting Overlay ===== */
.waiting-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 300;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 16px;
  backdrop-filter: blur(2px);
}
.waiting-overlay.active { display: flex; }

.waiting-dialog {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 32px;
  max-width: 640px;
  width: 90vw;
  text-align: center;
  box-shadow: var(--shadow);
}
.waiting-dialog h3 { color: var(--green); margin-bottom: 12px; }
.waiting-dialog p { color: var(--fg-secondary); font-size: 14px; margin-bottom: 8px; }

.waiting-spinner {
  display: inline-flex;
  gap: 6px;
  align-items: center;
  justify-content: center;
  margin-bottom: 16px;
}
.waiting-spinner .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent);
  animation: pulse 1.4s ease-in-out infinite;
}
.waiting-spinner .dot:nth-child(2) { animation-delay: 0.2s; }
.waiting-spinner .dot:nth-child(3) { animation-delay: 0.4s; }
@keyframes pulse {
  0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
  40% { opacity: 1; transform: scale(1.2); }
}

.waiting-dialog .waiting-edits {
  font-size: 14px;
  font-weight: 600;
  color: var(--green);
  margin-top: 12px;
}

.waiting-prompt {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 14px;
  font-family: var(--font-mono);
  font-size: 12px;
  color: var(--fg-primary);
  margin-top: 12px;
  cursor: pointer;
  user-select: all;
  word-break: break-word;
  text-align: left;
}


.clipboard-confirm {
  animation: clipboard-fade 2s ease-out forwards;
}
@keyframes clipboard-fade {
  0% { color: var(--green); }
  100% { color: var(--fg-dimmed); }
}

/* ===== Keyboard Shortcuts Help Overlay ===== */
.shortcuts-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 400;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(2px);
}
.shortcuts-overlay.active { display: flex; }
.shortcuts-dialog {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px 32px;
  max-width: 480px;
  width: 90vw;
  box-shadow: var(--shadow);
}
.shortcuts-dialog h3 {
  color: var(--fg-primary);
  margin-bottom: 16px;
  font-size: 16px;
}
.shortcuts-table {
  width: 100%;
  border-collapse: collapse;
}
.shortcuts-table td {
  padding: 6px 0;
  font-size: 13px;
  color: var(--fg-secondary);
  border-bottom: 1px solid var(--border);
}
.shortcuts-table tr:last-child td { border-bottom: none; }
.shortcuts-table kbd {
  display: inline-block;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 1px 6px;
  font-family: var(--font-mono);
  font-size: 12px;
  color: var(--fg-primary);
  min-width: 24px;
  text-align: center;
}
.shortcuts-table td:first-child {
  width: 120px;
  white-space: nowrap;
}

/* ===== Loading State ===== */
.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 80vh;
  color: var(--fg-muted);
  font-size: 15px;
}

/* ===== highlight.js Dark Theme (GitHub Dark Dimmed) ===== */
[data-theme="dark"] .hljs{color:#adbac7;background:#22272e}
[data-theme="dark"] .hljs-doctag,[data-theme="dark"] .hljs-keyword,[data-theme="dark"] .hljs-meta .hljs-keyword,[data-theme="dark"] .hljs-template-tag,[data-theme="dark"] .hljs-template-variable,[data-theme="dark"] .hljs-type,[data-theme="dark"] .hljs-variable.language_{color:#f47067}
[data-theme="dark"] .hljs-title,[data-theme="dark"] .hljs-title.class_,[data-theme="dark"] .hljs-title.class_.inherited__,[data-theme="dark"] .hljs-title.function_{color:#dcbdfb}
[data-theme="dark"] .hljs-attr,[data-theme="dark"] .hljs-attribute,[data-theme="dark"] .hljs-literal,[data-theme="dark"] .hljs-meta,[data-theme="dark"] .hljs-number,[data-theme="dark"] .hljs-operator,[data-theme="dark"] .hljs-selector-attr,[data-theme="dark"] .hljs-selector-class,[data-theme="dark"] .hljs-selector-id,[data-theme="dark"] .hljs-variable{color:#6cb6ff}
[data-theme="dark"] .hljs-meta .hljs-string,[data-theme="dark"] .hljs-regexp,[data-theme="dark"] .hljs-string{color:#96d0ff}
[data-theme="dark"] .hljs-built_in,[data-theme="dark"] .hljs-symbol{color:#f69d50}
[data-theme="dark"] .hljs-code,[data-theme="dark"] .hljs-comment,[data-theme="dark"] .hljs-formula{color:#768390}
[data-theme="dark"] .hljs-name,[data-theme="dark"] .hljs-quote,[data-theme="dark"] .hljs-selector-pseudo,[data-theme="dark"] .hljs-selector-tag{color:#8ddb8c}
[data-theme="dark"] .hljs-subst{color:#adbac7}
[data-theme="dark"] .hljs-section{color:#316dca;font-weight:700}
[data-theme="dark"] .hljs-bullet{color:#eac55f}
[data-theme="dark"] .hljs-emphasis{color:#adbac7;font-style:italic}
[data-theme="dark"] .hljs-strong{color:#adbac7;font-weight:700}
[data-theme="dark"] .hljs-addition{color:#b4f1b4;background-color:#1b4721}
[data-theme="dark"] .hljs-deletion{color:#ffd8d3;background-color:#78191b}

/* ===== highlight.js Light Theme (GitHub) ===== */
[data-theme="light"] .hljs{color:#24292e;background:#fff}
[data-theme="light"] .hljs-doctag,[data-theme="light"] .hljs-keyword,[data-theme="light"] .hljs-meta .hljs-keyword,[data-theme="light"] .hljs-template-tag,[data-theme="light"] .hljs-template-variable,[data-theme="light"] .hljs-type,[data-theme="light"] .hljs-variable.language_{color:#d73a49}
[data-theme="light"] .hljs-title,[data-theme="light"] .hljs-title.class_,[data-theme="light"] .hljs-title.class_.inherited__,[data-theme="light"] .hljs-title.function_{color:#6f42c1}
[data-theme="light"] .hljs-attr,[data-theme="light"] .hljs-attribute,[data-theme="light"] .hljs-literal,[data-theme="light"] .hljs-meta,[data-theme="light"] .hljs-number,[data-theme="light"] .hljs-operator,[data-theme="light"] .hljs-selector-attr,[data-theme="light"] .hljs-selector-class,[data-theme="light"] .hljs-selector-id,[data-theme="light"] .hljs-variable{color:#005cc5}
[data-theme="light"] .hljs-meta .hljs-string,[data-theme="light"] .hljs-regexp,[data-theme="light"] .hljs-string{color:#032f62}
[data-theme="light"] .hljs-built_in,[data-theme="light"] .hljs-symbol{color:#e36209}
[data-theme="light"] .hljs-code,[data-theme="light"] .hljs-comment,[data-theme="light"] .hljs-formula{color:#6a737d}
[data-theme="light"] .hljs-name,[data-theme="light"] .hljs-quote,[data-theme="light"] .hljs-selector-pseudo,[data-theme="light"] .hljs-selector-tag{color:#22863a}
[data-theme="light"] .hljs-subst{color:#24292e}
[data-theme="light"] .hljs-section{color:#005cc5;font-weight:700}
[data-theme="light"] .hljs-bullet{color:#735c0f}
[data-theme="light"] .hljs-emphasis{color:#24292e;font-style:italic}
[data-theme="light"] .hljs-strong{color:#24292e;font-weight:700}
[data-theme="light"] .hljs-addition{color:#22863a;background-color:#f0fff4}
[data-theme="light"] .hljs-deletion{color:#b31d28;background-color:#ffeef0}

/* ===== Per-line code scrollbar hiding =====
   Each code line is a separate scrollable element due to per-line commenting.
   Hide individual scrollbars — users scroll via touch/trackpad. */
.line-content.code-line {
  scrollbar-width: none;
}
.line-content.code-line::-webkit-scrollbar {
  height: 0;
}

/* ===== Table of Contents ===== */
.toc {
  position: fixed;
  top: 72px;
  right: 16px;
  width: 210px;
  max-height: calc(100vh - 88px);
  overflow-y: auto;
  z-index: 90;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: var(--shadow);
  font-size: 12px;
  transition: opacity 0.2s, transform 0.2s;
}
.toc.toc-hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateX(6px);
}
.toc-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 9px 12px 7px;
  border-bottom: 1px solid var(--border);
  font-weight: 600;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--fg-muted);
  background: var(--bg-secondary);
  position: sticky;
  top: 0;
}
.toc-close {
  background: none;
  border: none;
  color: var(--fg-muted);
  cursor: pointer;
  font-size: 14px;
  line-height: 1;
  padding: 1px 4px;
  border-radius: 3px;
  transition: all 0.15s;
}
.toc-close:hover { color: var(--fg-primary); background: var(--bg-hover); }
.toc-list {
  list-style: none;
  padding: 6px 0;
  margin: 0;
}
.toc-list li { margin: 0; }
.toc-list a {
  display: block;
  padding: 3px 12px;
  color: var(--fg-secondary);
  text-decoration: none;
  line-height: 1.45;
  border-left: 2px solid transparent;
  transition: color 0.1s, background 0.1s, border-color 0.1s;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.toc-list a:hover { color: var(--fg-primary); background: var(--bg-hover); }
.toc-list a.toc-active {
  color: var(--accent);
  border-left-color: var(--accent);
  background: var(--accent-subtle);
}

/* ===== Diff View ===== */
.diff-view {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0;
  max-width: 100%;
  padding: 0 16px;
}
.diff-view-side {
  min-width: 0;
  overflow-x: auto;
  border-right: 1px solid var(--border);
}
.diff-view-side:last-child {
  border-right: none;
}
.diff-view-side-label {
  padding: 8px 12px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-muted);
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}
.diff-view .line-block {
  grid-template-columns: 32px 1fr;
}
.diff-view .line-gutter {
  min-width: 32px;
}
.line-gutter.diff-no-comment { cursor: default; }
.line-gutter.diff-no-comment:hover .line-num { opacity: 1; }
.line-gutter.diff-no-comment:hover .line-add { opacity: 0; pointer-events: none; }
.diff-view .line-block.diff-added .line-content {
  background: rgba(158, 206, 106, 0.12);
}
.diff-view .line-block.diff-removed .line-content {
  background: rgba(247, 118, 142, 0.12);
  opacity: 0.7;
}
.diff-view .line-block.diff-removed .line-content * {
  text-decoration: line-through;
}

.diff-view-unified {
  grid-column: 1 / -1;
  max-width: 840px;
  margin: 0 auto;
  padding: 32px 0 120px 0;
  width: 100%;
}
.btn-group {
  display: inline-flex;
}
.btn-group .btn {
  border-radius: 0;
}
.btn-group .btn:first-child {
  border-radius: 6px 0 0 6px;
}
.btn-group .btn:last-child {
  border-radius: 0 6px 6px 0;
  border-left: none;
}
.btn.btn-active,
.btn-group .btn-active {
  background: var(--fg-muted);
  color: var(--bg);
}

/* ===== Responsive ===== */
@media (max-width: 900px) {
  .document-wrapper { padding-left: 8px; padding-right: 8px; }
  .comment-block, .comment-form-wrapper { padding-left: 8px; }
  .line-gutter { min-width: 36px; }
}
@media (max-width: 600px) {
  .toc, #tocToggle { display: none !important; }
  #diffToggle, #diffModeToggle { display: none !important; }
  #shortcutsToggle { display: none !important; }
}
@media (max-width: 600px) {
  /* Header: 3-row grid layout
     Row 1: Crit              theme-pill
     Row 2: filename.md (full width, truncated)
     Row 3: N comments  [Share]  Finish Review */
  .header {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 6px 8px;
    padding: 10px 14px;
    align-items: center;
  }
  .header-left, .header-right {
    display: contents;
  }
  /* Row 1: brand + theme */
  .header-title {
    grid-row: 1;
    grid-column: 1;
  }
  .theme-pill {
    grid-row: 1;
    grid-column: 3;
    justify-self: end;
    align-self: center;
    width: fit-content;
  }
  /* Row 2: filename full width */
  .header-filename {
    grid-row: 2;
    grid-column: 1 / -1;
    font-size: 12px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 4px;
  }
  /* Row 3: actions */
  .comment-count {
    grid-row: 3;
    grid-column: 1;
    justify-self: start;
    align-self: center;
  }
  #shareBtn {
    grid-row: 3;
    grid-column: 2;
    justify-self: end;
    font-size: 12px;
    padding: 4px 10px;
  }
  #finishBtn {
    grid-row: 3;
    grid-column: 3;
    justify-self: end;
    font-size: 12px;
    padding: 5px 10px;
  }
  .header-notify:empty {
    display: none;
  }
  .header-notify {
    grid-row: 4;
    grid-column: 1 / -1;
  }
  #headerUpdate {
    display: none !important;
  }

  /* Wrap long code lines on mobile instead of per-line scrolling */
  .line-content.code-line {
    white-space: pre-wrap;
    overflow-wrap: anywhere;
  }
}
.mini-toast {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--border);
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  opacity: 0;
  transition: opacity 0.3s, transform 0.3s;
  z-index: 1000;
  pointer-events: none;
}
.mini-toast-visible {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <span class="header-title">Crit</span>
    <span class="header-filename" id="filename"></span>
    <span class="header-update" id="headerUpdate" style="display:none">
      <a id="updateLink" href="https://github.com/tomasz-tomczyk/crit/releases/latest" target="_blank" rel="noopener noreferrer"></a>
      <button class="header-update-dismiss" onclick="dismissUpdate()" title="Dismiss">&#x2715;</button>
    </span>
  </div>
  <div class="header-right">
    <span class="comment-count" id="commentCount"></span>
    <span class="header-notify" id="headerNotify"></span>
    <button class="btn btn-sm" id="diffToggle" style="display:none">Toggle Diff</button>
    <div id="diffModeToggle" class="btn-group" style="display:none">
      <button class="btn btn-sm" id="diffModeSplit" title="Split view">Split</button>
      <button class="btn btn-sm" id="diffModeUnified" title="Unified view">Unified</button>
    </div>
    <button class="theme-toggle" id="shortcutsToggle" title="Keyboard shortcuts (?)" aria-label="Keyboard shortcuts">?</button>
    <button class="theme-toggle" id="tocToggle" title="Table of contents" aria-label="Table of contents">&#9776;</button>
    <div class="theme-pill" role="group" aria-label="Theme">
      <div class="theme-pill-indicator"></div>
      <button class="theme-pill-btn" data-for-theme="system" title="System theme" role="radio" aria-label="System theme">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M2 4.25A2.25 2.25 0 0 1 4.25 2h7.5A2.25 2.25 0 0 1 14 4.25v5.5A2.25 2.25 0 0 1 11.75 12h-1.312c.1.128.21.248.328.36a.75.75 0 0 1 .234.545v.345a.75.75 0 0 1-.75.75h-4.5a.75.75 0 0 1-.75-.75v-.345a.75.75 0 0 1 .234-.545c.118-.111.228-.232.328-.36H4.25A2.25 2.25 0 0 1 2 9.75v-5.5Zm2.25-.75a.75.75 0 0 0-.75.75v4.5c0 .414.336.75.75.75h7.5a.75.75 0 0 0 .75-.75v-4.5a.75.75 0 0 0-.75-.75h-7.5Z" clip-rule="evenodd"/></svg>
      </button>
      <button class="theme-pill-btn" data-for-theme="light" title="Light theme" role="radio" aria-label="Light theme">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M8 1a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 8 1ZM10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM12.95 4.11a.75.75 0 1 0-1.06-1.06l-1.062 1.06a.75.75 0 0 0 1.061 1.062l1.06-1.061ZM15 8a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1 0-1.5h1.5A.75.75 0 0 1 15 8ZM11.89 12.95a.75.75 0 0 0 1.06-1.06l-1.06-1.062a.75.75 0 0 0-1.062 1.061l1.061 1.06ZM8 12a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 8 12ZM5.172 11.89a.75.75 0 0 0-1.061-1.062L3.05 11.89a.75.75 0 1 0 1.06 1.06l1.06-1.06ZM4 8a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1 0-1.5h1.5A.75.75 0 0 1 4 8ZM4.11 5.172A.75.75 0 0 0 5.173 4.11L4.11 3.05a.75.75 0 1 0-1.06 1.06l1.06 1.06Z"/></svg>
      </button>
      <button class="theme-pill-btn" data-for-theme="dark" title="Dark theme" role="radio" aria-label="Dark theme">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M14.438 10.148c.19-.425-.321-.787-.748-.601A5.5 5.5 0 0 1 6.453 2.31c.186-.427-.176-.938-.6-.748a6.501 6.501 0 1 0 8.585 8.586Z"/></svg>
      </button>
    </div>
    <button class="btn" id="shareBtn" style="display:none">Share</button>
    <button class="btn btn-primary" id="finishBtn">Finish Review</button>
  </div>
</div>

<div id="toc" class="toc toc-hidden">
  <div class="toc-header">
    <span>Contents</span>
    <button class="toc-close" title="Close table of contents" aria-label="Close table of contents">&#x2715;</button>
  </div>
  <ul class="toc-list"></ul>
</div>

<div class="toast-container" id="toastContainer"></div>
<div class="bottom-toast-container" id="bottomToastContainer"></div>

<div id="diffView" class="diff-view" style="display:none"></div>

<div class="document-wrapper" id="document">
  <div class="loading">Loading document...</div>
</div>

<div class="waiting-overlay" id="waitingOverlay">
  <div class="waiting-dialog">
    <div class="waiting-spinner"><span class="dot"></span><span class="dot"></span><span class="dot"></span></div>
    <h3>Review Complete</h3>
    <p id="waitingMessage"></p>
    <p class="waiting-edits" id="waitingEdits"></p>
    <div class="waiting-prompt" id="waitingPrompt"></div>
    <p style="font-size: 12px; color: var(--fg-muted); margin-top: 8px;" id="waitingClipboard"></p>
    <button class="btn btn-sm" id="backToEditing" style="margin-top: 16px;">Back to editing</button>
  </div>
</div>

<div class="shortcuts-overlay" id="shortcutsOverlay">
  <div class="shortcuts-dialog">
    <h3>Keyboard Shortcuts</h3>
    <table class="shortcuts-table">
      <tr><td><kbd>j</kbd></td><td>Next block</td></tr>
      <tr><td><kbd>k</kbd></td><td>Previous block</td></tr>
      <tr><td><kbd>c</kbd></td><td>Comment on focused block</td></tr>
      <tr><td><kbd>e</kbd></td><td>Edit comment on focused block</td></tr>
      <tr><td><kbd>d</kbd></td><td>Delete comment on focused block</td></tr>
      <tr><td><kbd>Shift</kbd>+<kbd>F</kbd></td><td>Finish review</td></tr>
      <tr><td><kbd>t</kbd></td><td>Toggle table of contents</td></tr>
      <tr><td><kbd>Esc</kbd></td><td>Cancel / clear focus</td></tr>
      <tr><td><kbd>Ctrl</kbd>+<kbd>Enter</kbd></td><td>Submit comment</td></tr>
      <tr><td><kbd>?</kbd></td><td>Toggle this help</td></tr>
    </table>
  </div>
</div>

<script src="markdown-it.min.js"></script>
<script src="highlight.min.js"></script>
<script src="hljs-javascript.min.js"></script>
<script src="hljs-typescript.min.js"></script>
<script src="hljs-go.min.js"></script>
<script src="hljs-python.min.js"></script>
<script src="hljs-ruby.min.js"></script>
<script src="hljs-rust.min.js"></script>
<script src="hljs-sql.min.js"></script>
<script src="hljs-bash.min.js"></script>
<script src="hljs-json.min.js"></script>
<script src="hljs-yaml.min.js"></script>
<script src="hljs-xml.min.js"></script>
<script src="hljs-css.min.js"></script>
<script src="hljs-elixir.min.js"></script>
<script src="mermaid.min.js"></script>
<script>
(function() {
  'use strict';

  // ===== Comment Markdown Renderer =====
  const commentMd = window.markdownit({ html: false, linkify: true, typographer: true });

  // ===== State =====
  let comments = [];
  let rawContent = '';
  let fileName = '';
  let shareURL = '';
  let hostedURL = '';
  let deleteToken = '';
  let lineBlocks = []; // { startLine, endLine, html }
  let tocItems = []; // { level, text, startLine }
  let selectionStart = null;
  let selectionEnd = null;
  let activeForm = null; // { afterBlockIndex, startLine, endLine, editingId }
  let uiState = 'reviewing'; // 'reviewing' | 'waiting'
  let reviewRound = 1;
  let latestAvailableVersion = '';
  let previousComments = [];
  let previousRoundContent = ''; // raw markdown from previous round
  let diffEntries = []; // cached from /api/diff
  let diffActive = false; // true when diff view is shown
  let diffMode = 'split'; // 'split' | 'unified'
  let focusedBlockIndex = null; // index into lineBlocks for keyboard nav

  // ===== Mermaid =====
  let mermaidCounter = 0;
  const mermaidSources = {}; // id -> source text
  function getMermaidTheme() {
    const explicit = document.documentElement.getAttribute('data-theme');
    if (explicit === 'dark') return 'dark';
    if (explicit === 'light') return 'default';
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
  }
  mermaid.initialize({ startOnLoad: false, theme: getMermaidTheme() });

  async function renderMermaidBlocks() {
    const els = document.querySelectorAll('.mermaid-pending');
    if (els.length === 0) return;
    mermaid.initialize({ startOnLoad: false, theme: getMermaidTheme() });
    for (const el of els) {
      const srcId = el.getAttribute('data-mermaid-id');
      const source = mermaidSources[srcId];
      if (!source) continue;
      const renderId = 'mermaid-svg-' + (mermaidCounter++);
      try {
        const { svg } = await mermaid.render(renderId, source);
        el.innerHTML = svg;
        el.classList.remove('mermaid-pending');
        el.classList.add('mermaid-rendered');
      } catch (e) {
        // Render failed — show source as code block fallback
        el.innerHTML = '<pre><code>' + escapeHtml(source) + '</code></pre>';
        el.classList.remove('mermaid-pending');
      }
    }
  }

  // ===== Theme =====
  function applyTheme(theme) {
    if (theme === 'system') {
      localStorage.removeItem('crit-theme');
      document.documentElement.removeAttribute('data-theme');
    } else {
      localStorage.setItem('crit-theme', theme);
      document.documentElement.setAttribute('data-theme', theme);
    }
    document.querySelectorAll('.theme-pill-btn').forEach(function(btn) {
      btn.setAttribute('aria-checked', btn.dataset.forTheme === theme ? 'true' : 'false');
    });
  }

  applyTheme(localStorage.getItem('crit-theme') || 'system');

  document.querySelectorAll('.theme-pill-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      applyTheme(this.dataset.forTheme);
      reapplyHighlightTheme();
    });
  });

  function reapplyHighlightTheme() {
    // highlight.js themes are applied via CSS, which is handled by the data-theme attribute
    // Re-render mermaid diagrams with new theme
    document.querySelectorAll('.mermaid-rendered').forEach(function(el) {
      el.classList.remove('mermaid-rendered');
      el.classList.add('mermaid-pending');
    });
    renderMermaidBlocks();
  }

  // ===== ToC Toggle =====
  (function() {
    const tocEl = document.getElementById('toc');
    const saved = localStorage.getItem('crit-toc');
    if (saved === 'open' || (saved === null && window.innerWidth > 1200)) {
      tocEl.classList.remove('toc-hidden');
    }
    document.getElementById('tocToggle').addEventListener('click', function() {
      const isHidden = tocEl.classList.contains('toc-hidden');
      tocEl.classList.toggle('toc-hidden', !isHidden);
      localStorage.setItem('crit-toc', isHidden ? 'open' : 'closed');
    });
    tocEl.querySelector('.toc-close').addEventListener('click', function() {
      tocEl.classList.add('toc-hidden');
      localStorage.setItem('crit-toc', 'closed');
    });
  })();

  // ===== Scroll Spy =====
  var scrollSpyFrame = null;
  window.addEventListener('scroll', function() {
    if (scrollSpyFrame) return;
    scrollSpyFrame = requestAnimationFrame(function() {
      scrollSpyFrame = null;
      updateTocActive();
    });
  }, { passive: true });

  // ===== Init =====
  async function init() {
    try {
      const [docRes, commentsRes, staleRes, configRes] = await Promise.all([
        fetch('/api/document').then(r => r.json()),
        fetch('/api/comments').then(r => r.json()),
        fetch('/api/stale').then(r => r.json()),
        fetch('/api/config').then(r => r.json()),
      ]);

      rawContent = docRes.content;
      fileName = docRes.filename;
      comments = commentsRes || [];
      shareURL = configRes.share_url || '';
      hostedURL = configRes.hosted_url || '';
      deleteToken = configRes.delete_token || '';
      if (shareURL) document.getElementById('shareBtn').style.display = '';
      if (hostedURL) showSharedNotice(hostedURL);

      checkForUpdate(configRes.version || '', configRes.latest_version || '');

      document.getElementById('filename').textContent = fileName;
      document.title = `Crit — ${fileName}`;

      if (staleRes.notice) {
        showStaleNotice(staleRes.notice);
      }

      parseAndRender();
      updateCommentCount();

      // Restore round state on refresh — if previous round data exists, we're in round 2+
      try {
        const [diffResp, prevResp] = await Promise.all([
          fetch('/api/diff').then(r => r.json()),
          fetch('/api/previous-round').then(r => r.json()),
        ]);
        if (prevResp.content) {
          diffEntries = diffResp.entries || [];
          previousComments = prevResp.comments || [];
          previousRoundContent = prevResp.content || '';
          reviewRound = prevResp.review_round || 2;
          updateHeaderRound();
          if (diffEntries.length && previousRoundContent) {
            document.getElementById('diffToggle').style.display = '';
            parseAndRender(); // re-render with resolved comments
          } else if (previousComments.some(function(c) { return c.resolved; })) {
            parseAndRender();
          }
        }
      } catch (_) {}

      restoreDraft();
      showKeyboardHint();
    } catch (err) {
      document.getElementById('document').innerHTML =
        `<div class="loading" style="color:var(--red)">Error loading document: ${err.message}</div>`;
    }
  }

  function showKeyboardHint() {
    if (document.cookie.includes('crit-hint=1')) return;
    document.cookie = 'crit-hint=1; path=/; max-age=315360000; SameSite=Lax';
    const container = document.getElementById('bottomToastContainer');
    const el = document.createElement('div');
    el.className = 'toast success';
    el.dataset.toastId = 'keyboard-hint';
    el.innerHTML = `
      <span>Press <kbd style="background:var(--bg-tertiary);padding:2px 6px;border-radius:4px;font-family:var(--font-mono);font-size:12px;">?</kbd> for keyboard shortcuts</span>
      <div class="toast-actions">
        <button class="toast-btn toast-btn-ghost" onclick="dismissToast('keyboard-hint')">Got it</button>
      </div>
    `;
    container.appendChild(el);
    setTimeout(function() { dismissToast('keyboard-hint'); }, 5000);
  }

  // ===== Update Check =====
  function checkForUpdate(currentVer, latestVer) {
    if (!latestVer || !isNewerVersion(latestVer, currentVer)) return;
    if (localStorage.getItem('crit-dismissed-version') === latestVer) return;
    showUpdateNotice(latestVer);
  }

  function isNewerVersion(latest, current) {
    if (current === 'dev') return true;
    const parse = v => v.replace(/^v/, '').split('.').map(Number);
    const [lMaj, lMin, lPat] = parse(latest);
    const [cMaj, cMin, cPat] = parse(current);
    if (lMaj !== cMaj) return lMaj > cMaj;
    if (lMin !== cMin) return lMin > cMin;
    return lPat > cPat;
  }

  function showUpdateNotice(version) {
    latestAvailableVersion = version;
    document.getElementById('updateLink').textContent = version + ' available';
    document.getElementById('headerUpdate').style.display = 'flex';
  }

  window.dismissUpdate = function() {
    document.getElementById('headerUpdate').style.display = 'none';
    localStorage.setItem('crit-dismissed-version', latestAvailableVersion);
  };

  // ===== Toast Notifications =====
  function showToast(id, type, html) {
    dismissToast(id, true); // remove existing toast with same id instantly
    const container = document.getElementById('toastContainer');
    const el = document.createElement('div');
    el.className = `toast ${type}`;
    el.dataset.toastId = id;
    el.innerHTML = html;
    container.appendChild(el);
    return el;
  }

  window.dismissToast = function(id, instant) {
    const el = document.querySelector(`.toast[data-toast-id="${id}"]`);
    if (!el) return;
    if (instant) { el.remove(); return; }
    el.classList.add('toast-out');
    el.addEventListener('animationend', () => el.remove(), { once: true });
  };

  // ===== Stale Notice =====
  function showStaleNotice(msg) {
    const el = showToast('stale', 'warning', `
      <span>${msg}</span>
      <div class="toast-actions">
        <button class="toast-btn toast-btn-filled" onclick="dismissStale()">Keep Comments</button>
        <button class="toast-btn toast-btn-ghost" onclick="discardComments()">Discard</button>
      </div>
    `);
  }

  window.dismissStale = async function() {
    await fetch('/api/stale', { method: 'DELETE' });
    dismissToast('stale');
  };

  window.discardComments = async function() {
    for (const c of [...comments]) {
      await fetch(`/api/comments/${c.id}`, { method: 'DELETE' });
    }
    comments = [];
    await fetch('/api/stale', { method: 'DELETE' });
    dismissToast('stale');
    renderDocument();
    updateCommentCount();
  };

  // ===== Markdown Parsing with Source Line Mapping =====
  function parseAndRender() {
    const md = window.markdownit({
      html: true,
      typographer: true,
      linkify: true,
      highlight: function(str, lang) {
        if (lang && hljs.getLanguage(lang)) {
          try { return hljs.highlight(str, { language: lang }).value; } catch (_) {}
        }
        try { return hljs.highlightAuto(str).value; } catch (_) {}
        return '';
      }
    });

    // Enable task list rendering
    const defaultRender = md.renderer.rules.list_item_open || function(tokens, idx, options, env, self) {
      return self.renderToken(tokens, idx, options);
    };
    md.renderer.rules.list_item_open = function(tokens, idx, options, env, self) {
      const content = getListItemContent(tokens, idx);
      if (content !== null && /^\[[ x]\]\s/.test(content)) {
        tokens[idx].attrJoin('class', 'task-list-item');
      }
      return defaultRender(tokens, idx, options, env, self);
    };

    function getListItemContent(tokens, idx) {
      for (let i = idx + 1; i < tokens.length; i++) {
        if (tokens[i].type === 'list_item_close') break;
        if (tokens[i].type === 'inline') return tokens[i].content;
      }
      return null;
    }

    // Parse tokens to get source line mappings
    const tokens = md.parse(rawContent, {});

    // Extract headings for ToC
    tocItems = [];
    for (let ti = 0; ti < tokens.length; ti++) {
      const t = tokens[ti];
      if (t.type === 'heading_open' && t.map) {
        const level = parseInt(t.tag.slice(1));
        const inlineToken = tokens[ti + 1];
        tocItems.push({ level, text: inlineToken ? inlineToken.content : '', startLine: t.map[0] + 1 });
      }
    }

    lineBlocks = buildLineBlocks(tokens, md, rawContent);
    renderDocument();
    buildToc(tocItems);
  }

  // Split highlighted code HTML into per-line chunks,
  // properly handling <span> tags that cross line boundaries
  function splitHighlightedCode(html) {
    const rawLines = html.split('\n');
    const result = [];
    let openTags = []; // stack of open <span ...> tag strings

    for (const rawLine of rawLines) {
      const prefix = openTags.join('');
      const newOpenTags = [...openTags];
      const re = /<(\/?span)([^>]*)>/g;
      let m;
      while ((m = re.exec(rawLine)) !== null) {
        if (m[1] === '/span') {
          newOpenTags.pop();
        } else {
          newOpenTags.push('<span' + m[2] + '>');
        }
      }
      const suffix = '</span>'.repeat(newOpenTags.length);
      result.push(prefix + rawLine + suffix);
      openTags = newOpenTags;
    }
    return result;
  }

  function buildLineBlocks(tokens, md, source) {
    const sourceLines = source.split('\n');
    const totalLines = sourceLines.length;
    const blocks = [];
    let coveredUpTo = 0; // 0-indexed line we've covered up to (exclusive)

    function addGapLines(upTo) {
      for (let ln = coveredUpTo; ln < upTo; ln++) {
        blocks.push({
          startLine: ln + 1,
          endLine: ln + 1,
          html: sourceLines[ln].trim() === '' ? '' : escapeHtml(sourceLines[ln]),
          isEmpty: sourceLines[ln].trim() === ''
        });
      }
      if (upTo > coveredUpTo) coveredUpTo = upTo;
    }

    function findClose(startIdx) {
      let depth = 1;
      for (let j = startIdx + 1; j < tokens.length; j++) {
        depth += tokens[j].nesting;
        if (depth === 0) return j;
      }
      return startIdx;
    }

    let i = 0;
    while (i < tokens.length) {
      const token = tokens[i];

      if (token.nesting === -1 || !token.map) { i++; continue; }

      const blockStart = token.map[0];
      const blockEnd = token.map[1];

      addGapLines(blockStart);

      // === Lists: split into individual list items ===
      if (token.type === 'bullet_list_open' || token.type === 'ordered_list_open') {
        const isOrdered = token.type === 'ordered_list_open';
        const listTag = isOrdered ? 'ol' : 'ul';
        const listCloseIdx = findClose(i);
        let orderNum = 1;

        let j = i + 1;
        while (j < listCloseIdx) {
          if (tokens[j].type === 'list_item_open') {
            const itemCloseIdx = findClose(j);
            const itemMap = tokens[j].map;

            if (itemMap) {
              addGapLines(itemMap[0]);
              // Find the actual content end (exclude trailing blank lines
              // that markdown-it includes in the list_item map)
              let contentEnd = itemMap[1];
              for (let ln = itemMap[1] - 1; ln > itemMap[0]; ln--) {
                if (sourceLines[ln].trim() === '') {
                  contentEnd = ln;
                } else {
                  break;
                }
              }
              const itemTokens = tokens.slice(j, itemCloseIdx + 1);
              const startAttr = isOrdered ? ' start="' + orderNum + '"' : '';
              const itemHtml = '<' + listTag + startAttr + '>' +
                md.renderer.render(itemTokens, md.options, {}) +
                '</' + listTag + '>';
              blocks.push({
                startLine: itemMap[0] + 1,
                endLine: contentEnd,
                html: itemHtml,
                isEmpty: false
              });
              coveredUpTo = contentEnd;
              orderNum++;
            }
            j = itemCloseIdx + 1;
          } else {
            j++;
          }
        }

        i = listCloseIdx + 1;
        addGapLines(blockEnd);
        continue;
      }

      // === Code blocks (fence): split into per-line ===
      if (token.type === 'fence') {
        const lang = token.info ? token.info.trim().split(/\s+/)[0] : '';
        const code = token.content;

        // === Mermaid diagrams: render as single block ===
        if (lang === 'mermaid') {
          const srcId = 'msrc-' + blockStart;
          mermaidSources[srcId] = code.trim();
          blocks.push({
            startLine: blockStart + 1, endLine: blockEnd,
            html: '<div class="mermaid-pending" data-mermaid-id="' + srcId + '"></div>',
            isEmpty: false, cssClass: 'mermaid-block'
          });
          i++;
          coveredUpTo = blockEnd;
          continue;
        }

        let highlighted;
        if (lang && hljs.getLanguage(lang)) {
          try { highlighted = hljs.highlight(code, { language: lang }).value; } catch(_) { highlighted = escapeHtml(code); }
        } else {
          try { highlighted = hljs.highlightAuto(code).value; } catch(_) { highlighted = escapeHtml(code); }
        }

        const codeLines = splitHighlightedCode(highlighted);
        // Remove trailing empty line (content usually ends with \n)
        while (codeLines.length > 0 && codeLines[codeLines.length - 1].replace(/<[^>]*>/g, '').trim() === '') {
          codeLines.pop();
        }

        const fenceOpen = blockStart;     // 0-indexed, ``` line
        const fenceClose = blockEnd - 1;  // 0-indexed, closing ``` line
        const totalCodeLines = codeLines.length;

        // Opening fence line
        blocks.push({
          startLine: fenceOpen + 1, endLine: fenceOpen + 1,
          html: '<span class="fence-marker">' + escapeHtml(sourceLines[fenceOpen]) + '</span>',
          isEmpty: false, cssClass: 'code-line code-first'
        });

        // Each code line
        for (let ci = 0; ci < totalCodeLines; ci++) {
          blocks.push({
            startLine: fenceOpen + 2 + ci, endLine: fenceOpen + 2 + ci,
            html: '<code class="hljs">' + (codeLines[ci] || '&nbsp;') + '</code>',
            isEmpty: false, cssClass: 'code-line code-mid'
          });
        }

        // Closing fence line
        blocks.push({
          startLine: fenceClose + 1, endLine: fenceClose + 1,
          html: '<span class="fence-marker">' + escapeHtml(sourceLines[fenceClose]) + '</span>',
          isEmpty: false, cssClass: 'code-line code-last'
        });

        i++;
        coveredUpTo = blockEnd;
        continue;
      }

      // === Tables: split into per-row ===
      if (token.type === 'table_open') {
        const tableCloseIdx = findClose(i);
        // Count columns from the first row
        let numCols = 0;
        for (let j = i + 1; j < tableCloseIdx; j++) {
          if (tokens[j].type === 'th_open') numCols++;
          if (tokens[j].type === 'tr_close') break;
        }
        const colWidth = numCols > 0 ? (100 / numCols).toFixed(2) + '%' : 'auto';
        const colgroup = '<colgroup>' + ('<col style="width:' + colWidth + '">').repeat(numCols) + '</colgroup>';

        let rowIndex = 0;
        let bodyRowIndex = 0;
        let inThead = false;
        let j = i + 1;
        while (j < tableCloseIdx) {
          if (tokens[j].type === 'thead_open') { inThead = true; j++; continue; }
          if (tokens[j].type === 'thead_close') { inThead = false; j++; continue; }
          if (tokens[j].type === 'tbody_open' || tokens[j].type === 'tbody_close') { j++; continue; }

          if (tokens[j].type === 'tr_open') {
            const trCloseIdx = findClose(j);
            const trMap = tokens[j].map;
            if (trMap) {
              // Handle gap lines between rows (e.g., |---|---| separator)
              for (let ln = coveredUpTo; ln < trMap[0]; ln++) {
                const lineText = sourceLines[ln].trim();
                if (/^\|[\s\-:|]+\|$/.test(lineText) || /^[-:|][\s\-:|]*$/.test(lineText)) {
                  // Table separator line — render as thin visual divider
                  blocks.push({
                    startLine: ln + 1, endLine: ln + 1,
                    html: '', isEmpty: false, cssClass: 'table-separator'
                  });
                } else {
                  blocks.push({
                    startLine: ln + 1, endLine: ln + 1,
                    html: lineText === '' ? '' : escapeHtml(lineText),
                    isEmpty: lineText === ''
                  });
                }
              }
              coveredUpTo = trMap[0];

              const trTokens = tokens.slice(j, trCloseIdx + 1);
              const section = inThead ? 'thead' : 'tbody';
              const rowHtml = '<table class="split-table">' + colgroup +
                '<' + section + '>' +
                md.renderer.render(trTokens, md.options, {}) +
                '</' + section + '></table>';

              let cls = 'table-row';
              if (rowIndex === 0) cls += ' table-first';
              if (!inThead && bodyRowIndex % 2 === 1) cls += ' table-even';
              blocks.push({
                startLine: trMap[0] + 1, endLine: trMap[1],
                html: rowHtml, isEmpty: false, cssClass: cls
              });
              coveredUpTo = trMap[1];
              rowIndex++;
              if (!inThead) bodyRowIndex++;
            }
            j = trCloseIdx + 1;
          } else {
            j++;
          }
        }
        // Mark the last row
        if (blocks.length > 0 && blocks[blocks.length - 1].cssClass &&
            blocks[blocks.length - 1].cssClass.includes('table-row')) {
          blocks[blocks.length - 1].cssClass += ' table-last';
        }

        i = tableCloseIdx + 1;
        addGapLines(blockEnd);
        continue;
      }

      // === Blockquotes: split into child blocks ===
      if (token.type === 'blockquote_open') {
        const bqCloseIdx = findClose(i);
        // Process children inside the blockquote as individual blocks
        // wrapped in <blockquote>
        let j = i + 1;
        let hasChildren = false;
        while (j < bqCloseIdx) {
          if (tokens[j].nesting === -1 || !tokens[j].map) { j++; continue; }
          hasChildren = true;
          const childMap = tokens[j].map;
          let childCloseIdx = j;
          if (tokens[j].nesting === 1) {
            childCloseIdx = findClose(j);
          }
          addGapLines(childMap[0]);
          const childTokens = tokens.slice(j, childCloseIdx + 1);
          const childHtml = '<blockquote>' +
            md.renderer.render(childTokens, md.options, {}) +
            '</blockquote>';
          blocks.push({
            startLine: childMap[0] + 1,
            endLine: childMap[1],
            html: childHtml,
            isEmpty: false
          });
          coveredUpTo = childMap[1];
          j = childCloseIdx + 1;
        }
        if (!hasChildren) {
          // Render whole blockquote as single block
          const bqTokens = tokens.slice(i, bqCloseIdx + 1);
          blocks.push({
            startLine: blockStart + 1,
            endLine: blockEnd,
            html: md.renderer.render(bqTokens, md.options, {}),
            isEmpty: false
          });
          coveredUpTo = blockEnd;
        }
        i = bqCloseIdx + 1;
        addGapLines(blockEnd);
        continue;
      }

      // === Default: render as single block ===
      let closeIdx = i;
      if (token.nesting === 1) {
        closeIdx = findClose(i);
      }

      const blockTokens = tokens.slice(i, closeIdx + 1);
      let html;
      try {
        html = md.renderer.render(blockTokens, md.options, {});
      } catch (e) {
        html = escapeHtml(blockTokens.map(t => t.content || '').join(''));
      }

      blocks.push({
        startLine: blockStart + 1,
        endLine: blockEnd,
        html: html,
        isEmpty: false
      });

      i = closeIdx + 1;
      coveredUpTo = blockEnd;
    }

    // Remaining lines
    addGapLines(totalLines);

    return blocks;
  }

  // Process task list checkboxes in rendered HTML
  function processTaskLists(html) {
    return html.replace(
      /(<li[^>]*class="task-list-item"[^>]*>)\s*<p>\[([ x])\]\s*/gi,
      function(match, liTag, checked) {
        const checkbox = checked === 'x'
          ? '<input type="checkbox" checked disabled>'
          : '<input type="checkbox" disabled>';
        return liTag + '<p>' + checkbox;
      }
    ).replace(
      /(<li[^>]*class="task-list-item"[^>]*>)\[([ x])\]\s*/gi,
      function(match, liTag, checked) {
        const checkbox = checked === 'x'
          ? '<input type="checkbox" checked disabled>'
          : '<input type="checkbox" disabled>';
        return liTag + checkbox;
      }
    );
  }

  function rewriteImageSrcs(html) {
    return html.replace(/(<img\s[^>]*src=")([^"]+)(")/gi, function(match, pre, src, post) {
      if (/^https?:\/\/|^data:|^\//.test(src)) return match;
      return pre + '/files/' + src + post;
    });
  }

  function escapeHtml(str) {
    return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }

  // ===== Table of Contents =====
  function buildToc(items) {
    const tocEl = document.getElementById('toc');
    const listEl = tocEl.querySelector('.toc-list');
    const toggleBtn = document.getElementById('tocToggle');
    listEl.innerHTML = '';

    if (items.length === 0) {
      toggleBtn.style.display = 'none';
      return;
    }
    toggleBtn.style.display = '';

    const minLevel = Math.min(...items.map(i => i.level));
    for (const item of items) {
      const li = document.createElement('li');
      const a = document.createElement('a');
      a.href = '#';
      a.textContent = item.text;
      a.dataset.startLine = item.startLine;
      a.style.paddingLeft = (12 + (item.level - minLevel) * 10) + 'px';
      a.addEventListener('click', function(e) {
        e.preventDefault();
        scrollToLine(item.startLine);
      });
      li.appendChild(a);
      listEl.appendChild(li);
    }
    updateTocActive();
  }

  function getTocContainer() {
    if (!diffActive) return document.getElementById('document');
    if (diffMode === 'split') {
      var sides = document.getElementById('diffView').querySelectorAll('.diff-view-side');
      return sides.length > 1 ? sides[1] : document.getElementById('diffView');
    }
    return document.getElementById('diffView');
  }

  function scrollToLine(line) {
    const container = getTocContainer();
    const el = container.querySelector('.line-block[data-start-line="' + line + '"]');
    if (!el) return;
    const headerEl = document.querySelector('.header');
    const offset = headerEl ? headerEl.offsetHeight + 8 : 60;
    const y = el.getBoundingClientRect().top + window.scrollY - offset;
    window.scrollTo({ top: y, behavior: 'smooth' });
  }

  function updateTocActive() {
    if (tocItems.length === 0) return;
    const headerEl = document.querySelector('.header');
    const threshold = (headerEl ? headerEl.offsetHeight : 52) + 10;
    const container = getTocContainer();

    let activeLine = null;
    for (const item of tocItems) {
      const el = container.querySelector('.line-block[data-start-line="' + item.startLine + '"]');
      if (el && el.getBoundingClientRect().top <= threshold) {
        activeLine = item.startLine;
      }
    }

    document.querySelectorAll('.toc-list a').forEach(function(a) {
      a.classList.toggle('toc-active', parseInt(a.dataset.startLine) === activeLine);
    });
  }

  // ===== Render Document =====
  function renderDocument() {
    const container = document.getElementById('document');
    container.innerHTML = '';

    const commentsMap = buildCommentsMap();
    const resolvedMap = buildResolvedMap();

    for (let bi = 0; bi < lineBlocks.length; bi++) {
      const block = lineBlocks[bi];

      // Create line block
      const lineBlockEl = document.createElement('div');
      lineBlockEl.className = 'line-block';
      lineBlockEl.dataset.blockIndex = bi;
      lineBlockEl.dataset.startLine = block.startLine;
      lineBlockEl.dataset.endLine = block.endLine;

      // Check if this block has comments
      const blockComments = getCommentsForBlock(block, commentsMap);
      if (blockComments.length > 0) {
        lineBlockEl.classList.add('has-comment');
      }

      // Check selection
      if (selectionStart !== null && selectionEnd !== null) {
        if (block.startLine >= selectionStart && block.endLine <= selectionEnd) {
          lineBlockEl.classList.add('selected');
        }
      }

      // Keyboard focus
      if (focusedBlockIndex === bi) {
        lineBlockEl.classList.add('focused');
      }

      // Gutter
      const gutter = document.createElement('div');
      gutter.className = 'line-gutter';
      gutter.dataset.startLine = block.startLine;
      gutter.dataset.endLine = block.endLine;

      const lineNum = document.createElement('span');
      lineNum.className = 'line-num';
      lineNum.textContent = block.startLine === block.endLine
        ? block.startLine
        : `${block.startLine}`;

      const lineAdd = document.createElement('span');
      lineAdd.className = 'line-add';
      lineAdd.textContent = '+';

      gutter.appendChild(lineNum);
      gutter.appendChild(lineAdd);
      gutter.addEventListener('mousedown', handleGutterMouseDown);

      // Content
      const content = document.createElement('div');
      let contentClasses = 'line-content';
      if (block.isEmpty) contentClasses += ' empty-line';
      if (block.cssClass) contentClasses += ' ' + block.cssClass;
      content.className = contentClasses;
      let html = block.html;
      html = processTaskLists(html);
      html = rewriteImageSrcs(html);
      content.innerHTML = html;

      lineBlockEl.appendChild(gutter);
      lineBlockEl.appendChild(content);
      container.appendChild(lineBlockEl);

      // Render comments attached to this block
      for (const comment of blockComments) {
        container.appendChild(createCommentElement(comment));
      }

      // Render resolved comments from previous round
      const blockResolved = getResolvedForBlock(block, resolvedMap);
      for (const rc of blockResolved) {
        container.appendChild(createResolvedElement(rc));
      }

      // Render comment form if it's after this block
      if (activeForm && !activeForm.editingId && activeForm.afterBlockIndex === bi) {
        container.appendChild(createCommentForm());
      }
    }

    // Render mermaid diagrams after DOM is built
    renderMermaidBlocks();
  }

  function buildCommentsMap() {
    // Map comments to the block they should appear after (by end_line)
    const map = {};
    for (const c of comments) {
      const key = c.end_line;
      if (!map[key]) map[key] = [];
      map[key].push(c);
    }
    return map;
  }

  function getCommentsForBlock(block, commentsMap) {
    const result = [];
    for (let ln = block.startLine; ln <= block.endLine; ln++) {
      if (commentsMap[ln]) {
        result.push(...commentsMap[ln]);
      }
    }
    return result;
  }

  function buildResolvedMap() {
    const map = {};
    for (const c of previousComments) {
      if (!c.resolved || !c.resolution_lines || c.resolution_lines.length === 0) continue;
      // Place the resolved comment after the last resolution line
      const targetLine = Math.max(...c.resolution_lines);
      if (!map[targetLine]) map[targetLine] = [];
      map[targetLine].push(c);
    }
    return map;
  }

  function getResolvedForBlock(block, resolvedMap) {
    const result = [];
    for (let ln = block.startLine; ln <= block.endLine; ln++) {
      if (resolvedMap[ln]) {
        result.push(...resolvedMap[ln]);
      }
    }
    return result;
  }

  function createResolvedElement(comment) {
    const el = document.createElement('div');
    el.className = 'resolved-comment';
    el.innerHTML =
      '<div class="resolved-comment-header">' +
        '<span class="resolved-check">\u2713</span>' +
        '<span class="resolved-body">' + escapeHtml(comment.body) + '</span>' +
      '</div>' +
      (comment.resolution_note ? '<span class="resolved-note"><svg xmlns="http://www.w3.org/2000/svg" width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:-1px;margin-right:3px;flex-shrink:0"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><line x1="12" y1="7" x2="12" y2="11"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>' + escapeHtml(comment.resolution_note) + '</span>' : '');
    el.addEventListener('click', function() {
      el.classList.toggle('expanded');
    });
    return el;
  }

  // ===== Gutter Drag Selection (GitHub-style) =====
  let dragState = null; // { anchorStartLine, anchorEndLine, anchorBlockIndex }

  function handleGutterMouseDown(e) {
    e.preventDefault(); // prevent text selection
    const gutter = e.currentTarget;
    const startLine = parseInt(gutter.dataset.startLine);
    const endLine = parseInt(gutter.dataset.endLine);
    const blockEl = gutter.parentElement;
    const blockIndex = parseInt(blockEl.dataset.blockIndex);

    // Shift+click: extend selection from previous anchor
    if (e.shiftKey && selectionStart !== null) {
      const rangeStart = Math.min(selectionStart, startLine);
      const rangeEnd = Math.max(selectionEnd, endLine);
      let lastBlockIndex = 0;
      for (let i = 0; i < lineBlocks.length; i++) {
        if (lineBlocks[i].startLine >= rangeStart && lineBlocks[i].endLine <= rangeEnd) {
          lastBlockIndex = i;
        }
      }
      activeForm = { afterBlockIndex: lastBlockIndex, startLine: rangeStart, endLine: rangeEnd, editingId: null };
      selectionStart = rangeStart;
      selectionEnd = rangeEnd;
      renderDocument();
      if (diffActive) renderActiveDiffView();
      focusCommentTextarea();
      return;
    }

    // Start drag
    dragState = {
      anchorStartLine: startLine,
      anchorEndLine: endLine,
      anchorBlockIndex: blockIndex,
      currentStartLine: startLine,
      currentEndLine: endLine,
      currentBlockIndex: blockIndex
    };

    // Show immediate selection feedback
    selectionStart = startLine;
    selectionEnd = endLine;
    activeForm = null;
    renderDocument();
    if (diffActive) renderActiveDiffView();

    document.body.classList.add('dragging');
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
  }

  function handleDragMove(e) {
    if (!dragState) return;

    // Find which gutter element the mouse is over
    const el = document.elementFromPoint(e.clientX, e.clientY);
    if (!el) return;

    const lineBlock = el.closest('.line-block');
    if (!lineBlock) return;

    const hoverStartLine = parseInt(lineBlock.dataset.startLine);
    const hoverEndLine = parseInt(lineBlock.dataset.endLine);
    const hoverBlockIndex = parseInt(lineBlock.dataset.blockIndex);

    dragState.currentStartLine = hoverStartLine;
    dragState.currentEndLine = hoverEndLine;
    dragState.currentBlockIndex = hoverBlockIndex;

    // Update visual selection range
    selectionStart = Math.min(dragState.anchorStartLine, hoverStartLine);
    selectionEnd = Math.max(dragState.anchorEndLine, hoverEndLine);
    renderDocument();
    if (diffActive) renderActiveDiffView();
  }

  function handleDragEnd(e) {
    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('mouseup', handleDragEnd);
    document.body.classList.remove('dragging');

    if (!dragState) return;

    const rangeStart = Math.min(dragState.anchorStartLine, dragState.currentStartLine);
    const rangeEnd = Math.max(dragState.anchorEndLine, dragState.currentEndLine);

    // Find the last block index in the range
    let lastBlockIndex = 0;
    for (let i = 0; i < lineBlocks.length; i++) {
      if (lineBlocks[i].startLine >= rangeStart && lineBlocks[i].endLine <= rangeEnd) {
        lastBlockIndex = i;
      }
    }

    activeForm = {
      afterBlockIndex: lastBlockIndex,
      startLine: rangeStart,
      endLine: rangeEnd,
      editingId: null
    };

    selectionStart = rangeStart;
    selectionEnd = rangeEnd;
    dragState = null;
    renderDocument();
    if (diffActive) renderActiveDiffView();
    focusCommentTextarea();
  }

  function focusCommentTextarea() {
    requestAnimationFrame(() => {
      const ta = document.querySelector('.comment-form textarea');
      if (ta) ta.focus();
    });
  }

  // ===== Comment Form =====
  function createCommentForm() {
    const wrapper = document.createElement('div');
    wrapper.className = 'comment-form-wrapper';

    const form = document.createElement('div');
    form.className = 'comment-form';

    const header = document.createElement('div');
    header.className = 'comment-form-header';
    const lineRef = activeForm.startLine === activeForm.endLine
      ? `Line ${activeForm.startLine}`
      : `Lines ${activeForm.startLine}-${activeForm.endLine}`;
    header.textContent = activeForm.editingId ? `Editing comment on ${lineRef}` : `Comment on ${lineRef}`;

    const textarea = document.createElement('textarea');
    textarea.placeholder = 'Leave a review comment... (Ctrl+Enter to submit, Escape to cancel)';
    if (activeForm.editingId) {
      const existing = comments.find(c => c.id === activeForm.editingId);
      if (existing) textarea.value = existing.body;
    }

    textarea.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        submitComment(textarea.value);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelComment();
      }
    });
    textarea.addEventListener('input', function() { debouncedSaveDraft(textarea.value); });

    const actions = document.createElement('div');
    actions.className = 'comment-form-actions';

    const suggestBtn = document.createElement('button');
    suggestBtn.className = 'btn btn-sm';
    suggestBtn.textContent = '\u00B1 Suggest';
    suggestBtn.title = 'Insert the selected lines as a suggestion';
    suggestBtn.style.marginRight = 'auto';
    suggestBtn.addEventListener('click', () => insertSuggestion(textarea));

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-sm';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', cancelComment);

    const submitBtn = document.createElement('button');
    submitBtn.className = 'btn btn-sm btn-primary';
    submitBtn.textContent = activeForm.editingId ? 'Update Comment' : 'Add Comment';
    submitBtn.addEventListener('click', () => submitComment(textarea.value));

    actions.appendChild(suggestBtn);
    actions.appendChild(cancelBtn);
    actions.appendChild(submitBtn);

    form.appendChild(header);
    form.appendChild(textarea);
    form.appendChild(actions);
    wrapper.appendChild(form);
    return wrapper;
  }

  async function submitComment(body) {
    if (!body.trim()) return;
    clearDraft();

    try {
      if (activeForm.editingId) {
        const res = await fetch(`/api/comments/${activeForm.editingId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ body: body.trim() })
        });
        const updated = await res.json();
        const idx = comments.findIndex(c => c.id === activeForm.editingId);
        if (idx >= 0) comments[idx] = updated;
      } else {
        const res = await fetch('/api/comments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            start_line: activeForm.startLine,
            end_line: activeForm.endLine,
            body: body.trim()
          })
        });
        const newComment = await res.json();
        comments.push(newComment);
      }
    } catch (err) {
      console.error('Error saving comment:', err);
    }

    activeForm = null;
    selectionStart = null;
    selectionEnd = null;
    renderDocument();
    if (diffActive) renderActiveDiffView();
    updateCommentCount();
  }

  function cancelComment() {
    clearDraft();
    activeForm = null;
    selectionStart = null;
    selectionEnd = null;
    renderDocument();
    if (diffActive) renderActiveDiffView();
  }

  // ===== Draft Autosave =====
  let draftTimer = null;

  function getDraftKey() {
    return 'crit-draft-' + fileName;
  }

  function saveDraft(body) {
    if (!activeForm) return;
    try {
      localStorage.setItem(getDraftKey(), JSON.stringify({
        startLine: activeForm.startLine,
        endLine: activeForm.endLine,
        afterBlockIndex: activeForm.afterBlockIndex,
        editingId: activeForm.editingId,
        body: body,
        savedAt: Date.now()
      }));
    } catch (_) {}
  }

  function debouncedSaveDraft(body) {
    clearTimeout(draftTimer);
    draftTimer = setTimeout(function() { saveDraft(body); }, 500);
  }

  function clearDraft() {
    clearTimeout(draftTimer);
    try { localStorage.removeItem(getDraftKey()); } catch (_) {}
  }

  window.addEventListener('beforeunload', function() {
    if (!activeForm) return;
    const ta = document.querySelector('.comment-form textarea, .comment-form-wrapper textarea');
    if (ta) saveDraft(ta.value);
  });

  function restoreDraft() {
    try {
      var raw = localStorage.getItem(getDraftKey());
      if (!raw) return;
      var draft = JSON.parse(raw);

      // Discard drafts older than 24 hours
      if (Date.now() - draft.savedAt > 24 * 60 * 60 * 1000) {
        localStorage.removeItem(getDraftKey());
        return;
      }

      // Verify line range exists in current document
      var totalLines = rawContent.split('\n').length;
      if (draft.startLine < 1 || draft.endLine > totalLines) {
        localStorage.removeItem(getDraftKey());
        return;
      }

      // If editing, verify comment still exists
      if (draft.editingId) {
        if (!comments.find(function(c) { return c.id === draft.editingId; })) {
          localStorage.removeItem(getDraftKey());
          return;
        }
      }

      // Restore activeForm and re-render
      activeForm = {
        afterBlockIndex: draft.afterBlockIndex,
        startLine: draft.startLine,
        endLine: draft.endLine,
        editingId: draft.editingId
      };
      selectionStart = draft.startLine;
      selectionEnd = draft.endLine;
      renderDocument();

      // Populate textarea with saved body
      requestAnimationFrame(function() {
        var ta = document.querySelector('.comment-form textarea, .comment-form-wrapper textarea');
        if (ta && draft.body) {
          ta.value = draft.body;
          ta.focus();
        }
      });

      showMiniToast('Draft restored');
    } catch (_) {}
  }

  function showMiniToast(message) {
    var t = document.createElement('div');
    t.className = 'mini-toast';
    t.textContent = message;
    document.body.appendChild(t);
    requestAnimationFrame(function() { t.classList.add('mini-toast-visible'); });
    setTimeout(function() {
      t.classList.remove('mini-toast-visible');
      setTimeout(function() { t.remove(); }, 300);
    }, 3000);
  }

  function insertSuggestion(textarea) {
    const lines = rawContent.split('\n').slice(activeForm.startLine - 1, activeForm.endLine);
    const suggestion = '```suggestion\n' + lines.join('\n') + '\n```';
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    textarea.value = textarea.value.substring(0, start) + suggestion + textarea.value.substring(end);
    // Place cursor inside the code block for editing
    const cursorPos = start + '```suggestion\n'.length;
    textarea.selectionStart = cursorPos;
    textarea.selectionEnd = cursorPos + lines.join('\n').length;
    textarea.focus();
  }

  // ===== Comment Display =====
  function createCommentElement(comment) {
    // If this comment is being edited, render an inline editor instead
    if (activeForm && activeForm.editingId === comment.id) {
      return createInlineEditor(comment);
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'comment-block';

    const card = document.createElement('div');
    card.className = 'comment-card' + (comment.carried_forward ? ' carried-forward' : '');

    const header = document.createElement('div');
    header.className = 'comment-header';

    const lineRef = document.createElement('span');
    lineRef.className = 'comment-line-ref';
    lineRef.textContent = comment.start_line === comment.end_line
      ? `Line ${comment.start_line}`
      : `Lines ${comment.start_line}-${comment.end_line}`;

    const time = document.createElement('span');
    time.className = 'comment-time';
    time.textContent = formatTime(comment.created_at);

    const headerLeft = document.createElement('div');
    headerLeft.style.display = 'flex';
    headerLeft.style.alignItems = 'center';
    headerLeft.style.gap = '10px';
    headerLeft.appendChild(lineRef);
    if (comment.carried_forward) {
      const label = document.createElement('span');
      label.className = 'carried-forward-label';
      label.textContent = 'Unresolved';
      headerLeft.appendChild(label);
    }
    headerLeft.appendChild(time);

    const actions = document.createElement('div');
    actions.className = 'comment-actions';

    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.addEventListener('click', () => editComment(comment));

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = 'Delete';
    deleteBtn.addEventListener('click', () => deleteComment(comment.id));

    actions.appendChild(editBtn);
    actions.appendChild(deleteBtn);

    header.appendChild(headerLeft);
    header.appendChild(actions);

    const body = document.createElement('div');
    body.className = 'comment-body';
    body.innerHTML = commentMd.render(comment.body);

    card.appendChild(header);
    card.appendChild(body);
    wrapper.appendChild(card);
    return wrapper;
  }

  function createInlineEditor(comment) {
    const wrapper = document.createElement('div');
    wrapper.className = 'comment-form-wrapper';

    const form = document.createElement('div');
    form.className = 'comment-form';

    const header = document.createElement('div');
    header.className = 'comment-form-header';
    const lineRef = comment.start_line === comment.end_line
      ? `Line ${comment.start_line}`
      : `Lines ${comment.start_line}-${comment.end_line}`;
    header.textContent = `Editing comment on ${lineRef}`;

    const textarea = document.createElement('textarea');
    textarea.placeholder = 'Leave a review comment... (Ctrl+Enter to submit, Escape to cancel)';
    textarea.value = comment.body;

    textarea.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        submitComment(textarea.value);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelComment();
      }
    });
    textarea.addEventListener('input', function() { debouncedSaveDraft(textarea.value); });

    const actions = document.createElement('div');
    actions.className = 'comment-form-actions';

    const suggestBtn = document.createElement('button');
    suggestBtn.className = 'btn btn-sm';
    suggestBtn.textContent = '\u00B1 Suggest';
    suggestBtn.title = 'Insert the selected lines as a suggestion';
    suggestBtn.style.marginRight = 'auto';
    suggestBtn.addEventListener('click', () => insertSuggestion(textarea));

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-sm';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', cancelComment);

    const submitBtn = document.createElement('button');
    submitBtn.className = 'btn btn-sm btn-primary';
    submitBtn.textContent = 'Update Comment';
    submitBtn.addEventListener('click', () => submitComment(textarea.value));

    actions.appendChild(suggestBtn);
    actions.appendChild(cancelBtn);
    actions.appendChild(submitBtn);

    form.appendChild(header);
    form.appendChild(textarea);
    form.appendChild(actions);
    wrapper.appendChild(form);

    requestAnimationFrame(() => textarea.focus());
    return wrapper;
  }

  function editComment(comment) {
    activeForm = {
      afterBlockIndex: null, // not used for inline edit
      startLine: comment.start_line,
      endLine: comment.end_line,
      editingId: comment.id
    };
    renderDocument();
  }

  async function deleteComment(id) {
    try {
      await fetch(`/api/comments/${id}`, { method: 'DELETE' });
      comments = comments.filter(c => c.id !== id);
    } catch (err) {
      console.error('Error deleting comment:', err);
    }
    renderDocument();
    updateCommentCount();
  }

  function formatTime(isoStr) {
    if (!isoStr) return '';
    const d = new Date(isoStr);
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  // ===== Comment Count =====
  function updateCommentCount() {
    const el = document.getElementById('commentCount');
    const n = comments.length;
    el.innerHTML = n === 0 ? '' : `<strong>${n}</strong> comment${n === 1 ? '' : 's'}`;
  }

  // ===== UI State Management =====
  function updateHeaderRound() {
    document.getElementById('headerNotify').textContent = 'Round #' + reviewRound;
  }

  function setUIState(state) {
    uiState = state;
    const finishBtn = document.getElementById('finishBtn');
    const waitingOverlay = document.getElementById('waitingOverlay');

    switch (state) {
      case 'reviewing':
        finishBtn.textContent = 'Finish Review';
        finishBtn.disabled = false;
        finishBtn.classList.add('btn-primary');
        document.getElementById('waitingEdits').textContent = '';
        waitingOverlay.classList.remove('active');
        break;
      case 'waiting':
        finishBtn.textContent = 'Waiting...';
        finishBtn.disabled = true;
        finishBtn.classList.remove('btn-primary');
        document.getElementById('waitingEdits').textContent = '';
        waitingOverlay.classList.add('active');
        break;
    }
  }

  // ===== Finish Review =====
  document.getElementById('finishBtn').addEventListener('click', async function() {
    if (uiState !== 'reviewing') return;

    try {
      const resp = await fetch('/api/finish', { method: 'POST' });
      const data = await resp.json();
      const hasComments = !!data.prompt;
      const prompt = data.prompt || 'I reviewed the plan, no feedback, good to go!';

      document.getElementById('waitingPrompt').textContent = prompt;

      if (hasComments) {
        document.getElementById('waitingMessage').innerHTML =
          'Paste the prompt below to your agent, then wait for <strong>' + escapeHtml(fileName) + '</strong> to be updated.';
        const clipEl = document.getElementById('waitingClipboard');
        clipEl.textContent = '\u2713 Copied to clipboard';
        clipEl.classList.remove('clipboard-confirm');
        void clipEl.offsetWidth;
        clipEl.classList.add('clipboard-confirm');
      } else {
        document.getElementById('waitingMessage').textContent =
          'You can close this browser tab, or leave it open for another round.';
        document.getElementById('waitingClipboard').textContent = '';
      }

      try { await navigator.clipboard.writeText(prompt); } catch (_) {}
    } catch (_) {}

    setUIState('waiting');
  });

  // Back to editing from waiting state
  document.getElementById('backToEditing').addEventListener('click', function() {
    setUIState('reviewing');
  });

  // ===== Share =====
  function showSharedNotice(url) {
    const unpublishBtn = deleteToken
      ? `<button class="toast-btn toast-btn-danger" id="shareUnpublishBtn">Unpublish</button>`
      : '';
    const el = showToast('share', 'success', `
      <span>Shared! <span class="toast-url">${escapeHtml(url)}</span></span>
      <div class="toast-actions">
        <button class="toast-btn toast-btn-filled" id="shareCopyBtn">Copy link</button>
        ${unpublishBtn}
        <button class="toast-btn toast-btn-ghost" onclick="dismissToast('share')">Dismiss</button>
      </div>
    `);
    el.querySelector('#shareCopyBtn').addEventListener('click', async function() {
      await navigator.clipboard.writeText(url).catch(() => {});
      this.textContent = '\u2713 Copied';
      setTimeout(() => { this.textContent = 'Copy link'; }, 2000);
    });
    if (deleteToken) {
      el.querySelector('#shareUnpublishBtn').addEventListener('click', handleUnpublish);
    }
  }

  async function handleUnpublish() {
    const btn = document.getElementById('shareUnpublishBtn');
    if (btn) { btn.textContent = 'Unpublishing…'; btn.disabled = true; }

    try {
      const resp = await fetch(shareURL + '/api/reviews', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ delete_token: deleteToken }),
      });

      const alreadyDeleted = resp.status === 404;
      if (!alreadyDeleted && !resp.ok) {
        throw new Error('Server error ' + resp.status);
      }

      hostedURL = '';
      deleteToken = '';
      fetch('/api/share-url', { method: 'DELETE' }).catch(() => {});

      const message = alreadyDeleted ? 'Already deleted.' : 'Review unpublished.';
      showToast('share', 'success', `
        <span>${message}</span>
        <div class="toast-actions">
          <button class="toast-btn toast-btn-ghost" onclick="dismissToast('share')">Dismiss</button>
        </div>
      `);
    } catch (err) {
      const el = showToast('share', 'error', `
        <span>Unpublish failed: ${escapeHtml(err.message)}</span>
        <div class="toast-actions">
          <button class="toast-btn toast-btn-filled" id="shareUnpublishRetryBtn">Retry</button>
          <button class="toast-btn toast-btn-ghost" onclick="dismissToast('share')">Dismiss</button>
        </div>
      `);
      el.querySelector('#shareUnpublishRetryBtn').addEventListener('click', () => {
        dismissToast('share');
        handleUnpublish();
      });
    }
  }

  document.getElementById('shareBtn').addEventListener('click', async function() {
    if (hostedURL) {
      showSharedNotice(hostedURL);
      return;
    }

    const btn = this;
    btn.textContent = 'Sharing…';
    btn.disabled = true;
    dismissToast('share');

    const payload = {
      content: rawContent,
      filename: fileName,
      comments: comments.map(c => ({
        start_line: c.start_line,
        end_line: c.end_line,
        body: c.body,
      })),
    };

    try {
      const resp = await fetch(shareURL + '/api/reviews', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!resp.ok) {
        const err = await resp.json().catch(() => ({}));
        throw new Error(err.error || 'Server error ' + resp.status);
      }

      const { url, delete_token } = await resp.json();
      hostedURL = url;
      deleteToken = delete_token || '';
      showSharedNotice(url);
      fetch('/api/share-url', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url, delete_token: deleteToken }),
      }).catch(() => {});
    } catch (err) {
      const el = showToast('share', 'error', `
        <span>Share failed: ${escapeHtml(err.message)}</span>
        <div class="toast-actions">
          <button class="toast-btn toast-btn-filled" id="shareRetryBtn">Retry</button>
          <button class="toast-btn toast-btn-ghost" onclick="dismissToast('share')">Dismiss</button>
        </div>
      `);
      el.querySelector('#shareRetryBtn').addEventListener('click', () => {
        dismissToast('share');
        document.getElementById('shareBtn').click();
      });
    } finally {
      btn.textContent = 'Share';
      btn.disabled = false;
    }
  });



  // ===== SSE Client =====
  function connectSSE() {
    const source = new EventSource('/api/events');

    source.addEventListener('file-changed', async function(e) {
      try {
        const data = JSON.parse(e.data);
        rawContent = data.content;
        fileName = data.filename;

        // Clear comments and re-render
        comments = [];
        activeForm = null;
        selectionStart = null;
        selectionEnd = null;
        focusedBlockIndex = null;
        parseAndRender();
        updateCommentCount();

        document.getElementById('filename').textContent = fileName;
        document.title = 'Crit — ' + fileName;

        reviewRound++;
        updateHeaderRound();
        setUIState('reviewing');

        // Fetch diff, previous round data, and carried-forward comments
        try {
          const [diffResp, prevResp, commentsResp] = await Promise.all([
            fetch('/api/diff').then(r => r.json()),
            fetch('/api/previous-round').then(r => r.json()),
            fetch('/api/comments').then(r => r.json()),
          ]);
          diffEntries = diffResp.entries || [];
          previousComments = prevResp.comments || [];
          previousRoundContent = prevResp.content || '';

          // Load carried-forward unresolved comments from previous round
          if (Array.isArray(commentsResp)) {
            comments = commentsResp;
          }

          if (diffEntries.length && previousRoundContent) {
            document.getElementById('diffToggle').style.display = '';
          }
          // Re-render to pick up resolved comments and carried-forward comments
          parseAndRender();
          updateCommentCount();
          setDiffActive(false);
        } catch (_) {}
      } catch (err) {
        console.error('Error handling file-changed event:', err);
      }
    });

    source.addEventListener('edit-detected', function(e) {
      try {
        const data = JSON.parse(e.data);
        const count = parseInt(data.content, 10);
        const el = document.getElementById('waitingEdits');
        if (el && uiState === 'waiting') {
          el.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:-3px;margin-right:4px"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><line x1="12" y1="7" x2="12" y2="11"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>Your agent made ' + count + ' edit' + (count === 1 ? '' : 's');
        }
      } catch (err) {
        console.error('Error handling edit-detected:', err);
      }
    });

    source.addEventListener('server-shutdown', function() {
      source.close();
      showDisconnected();
    });

    source.onerror = function() {
      // EventSource auto-reconnects, nothing to do
    };
  }

  function showDisconnected() {
    var overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:10000';
    var box = document.createElement('div');
    box.style.cssText = 'background:var(--bg-primary,#1e1e2e);border:1px solid var(--border-color,#45475a);border-radius:12px;padding:32px 40px;text-align:center;color:var(--text-primary,#cdd6f4);font-family:inherit';
    box.innerHTML = '<div style="font-size:20px;font-weight:600;margin-bottom:8px">Server stopped</div><div style="color:var(--text-secondary,#a6adc8)">You can close this tab.</div>';
    overlay.appendChild(box);
    document.body.appendChild(overlay);
  }

  // ===== Diff View (rendered markdown) =====
  function buildDiffLineSet(entries, side) {
    // Build sets of line numbers that are added/removed
    const added = new Set();
    const removed = new Set();
    for (const e of entries) {
      if (e.type === 'added') added.add(e.new_line);
      if (e.type === 'removed') removed.add(e.old_line);
    }
    return { added: added, removed: removed };
  }

  function classifyBlock(block, addedLines, removedLines, side) {
    // Check if any source line in this block overlaps with changed lines
    for (let ln = block.startLine; ln <= block.endLine; ln++) {
      if (side === 'new' && addedLines.has(ln)) return 'diff-added';
      if (side === 'old' && removedLines.has(ln)) return 'diff-removed';
    }
    return '';
  }

  function renderActiveDiffView() {
    if (diffMode === 'split') renderDiffView();
    else renderUnifiedDiffView();
  }


  function renderBlock(block, diffClassFn, resolvedMap, options) {
    options = options || {};
    const frag = document.createDocumentFragment();

    const lineBlockEl = document.createElement('div');
    lineBlockEl.className = 'line-block';
    lineBlockEl.dataset.startLine = block.startLine;
    lineBlockEl.dataset.endLine = block.endLine;
    if (options.blockIndex !== undefined) lineBlockEl.dataset.blockIndex = options.blockIndex;
    if (diffClassFn) {
      const cls = diffClassFn(block);
      if (cls) lineBlockEl.classList.add(cls);
    }

    // Selection/focused highlighting for commentable blocks
    if (options.commentable) {
      if (selectionStart !== null && block.endLine >= selectionStart && block.startLine <= selectionEnd) {
        lineBlockEl.classList.add('selected');
      }
      if (activeForm && !activeForm.editingId && block.endLine >= activeForm.startLine && block.startLine <= activeForm.endLine) {
        lineBlockEl.classList.add('focused');
      }
    }

    const gutter = document.createElement('div');
    gutter.className = 'line-gutter';
    if (!options.commentable) gutter.classList.add('diff-no-comment');
    gutter.dataset.startLine = block.startLine;
    gutter.dataset.endLine = block.endLine;
    const lineNum = document.createElement('span');
    lineNum.className = 'line-num';
    lineNum.textContent = block.startLine;
    gutter.appendChild(lineNum);

    if (options.commentable) {
      const lineAdd = document.createElement('span');
      lineAdd.className = 'line-add';
      lineAdd.textContent = '+';
      gutter.appendChild(lineAdd);
      gutter.addEventListener('mousedown', handleGutterMouseDown);
    }

    const contentEl = document.createElement('div');
    let contentClasses = 'line-content';
    if (block.isEmpty) contentClasses += ' empty-line';
    if (block.cssClass) contentClasses += ' ' + block.cssClass;
    contentEl.className = contentClasses;
    let html = block.html;
    html = processTaskLists(html);
    html = rewriteImageSrcs(html);
    contentEl.innerHTML = html;

    // Check if this block has comments
    if (options.commentsMap) {
      const blockComments = getCommentsForBlock(block, options.commentsMap);
      if (blockComments.length > 0) lineBlockEl.classList.add('has-comment');
    }

    lineBlockEl.appendChild(gutter);
    lineBlockEl.appendChild(contentEl);
    frag.appendChild(lineBlockEl);

    // Render active comments for commentable blocks
    if (options.commentsMap) {
      const blockComments = getCommentsForBlock(block, options.commentsMap);
      for (const comment of blockComments) {
        frag.appendChild(createCommentElement(comment));
      }
    }

    // Resolved comments after the line-block
    if (resolvedMap) {
      const blockResolved = getResolvedForBlock(block, resolvedMap);
      for (const rc of blockResolved) {
        frag.appendChild(createResolvedElement(rc));
      }
    }

    // Comment form after the matching block
    if (options.commentable && activeForm && !activeForm.editingId && options.blockIndex === activeForm.afterBlockIndex) {
      frag.appendChild(createCommentForm());
    }

    return frag;
  }

  function renderDiffSide(blocks, diffClass, resolvedMap, commentable) {
    const commentsMap = commentable ? buildCommentsMap() : null;
    const container = document.createElement('div');
    for (let bi = 0; bi < blocks.length; bi++) {
      container.appendChild(renderBlock(blocks[bi], diffClass, resolvedMap,
        { commentable: commentable, blockIndex: bi, commentsMap: commentsMap }));
    }
    return container;
  }

  function buildPreviousRoundBlocks() {
    const md = window.markdownit({ html: true, typographer: true, linkify: true,
      highlight: function(str, lang) {
        if (lang && hljs.getLanguage(lang)) {
          try { return hljs.highlight(str, { language: lang }).value; } catch (_) {}
        }
        try { return hljs.highlightAuto(str).value; } catch (_) {}
        return '';
      }
    });
    const oldTokens = md.parse(previousRoundContent, {});
    return buildLineBlocks(oldTokens, md, previousRoundContent);
  }

  function renderDiffView() {
    if (!diffEntries.length || !previousRoundContent) return;

    const diffEl = document.getElementById('diffView');
    diffEl.innerHTML = '';

    const sets = buildDiffLineSet(diffEntries);

    // Parse and build blocks for previous round
    const oldBlocks = buildPreviousRoundBlocks();

    // Use the current lineBlocks (already parsed)
    const newBlocks = lineBlocks;

    const resolvedMap = buildResolvedMap();

    // Left side (previous)
    const leftSide = document.createElement('div');
    leftSide.className = 'diff-view-side';
    const leftLabel = document.createElement('div');
    leftLabel.className = 'diff-view-side-label';
    leftLabel.textContent = 'Previous round';
    leftSide.appendChild(leftLabel);
    leftSide.appendChild(renderDiffSide(oldBlocks, function(block) {
      return classifyBlock(block, sets.added, sets.removed, 'old');
    }, null, false));

    // Right side (current)
    const rightSide = document.createElement('div');
    rightSide.className = 'diff-view-side';
    const rightLabel = document.createElement('div');
    rightLabel.className = 'diff-view-side-label';
    rightLabel.textContent = 'Current round';
    rightSide.appendChild(rightLabel);
    rightSide.appendChild(renderDiffSide(newBlocks, function(block) {
      return classifyBlock(block, sets.added, sets.removed, 'new');
    }, resolvedMap, true));

    diffEl.appendChild(leftSide);
    diffEl.appendChild(rightSide);
  }

  function renderUnifiedDiffView() {
    if (!diffEntries.length || !previousRoundContent) return;

    const sets = buildDiffLineSet(diffEntries);

    // Parse and build blocks for previous round
    const oldBlocks = buildPreviousRoundBlocks();

    // Use the current lineBlocks (already parsed)
    const newBlocks = lineBlocks;

    const resolvedMap = buildResolvedMap();

    const container = document.createElement('div');
    container.className = 'diff-view-unified';

    const commentsMap = buildCommentsMap();
    let oldIdx = 0;
    let newIdx = 0;

    while (oldIdx < oldBlocks.length || newIdx < newBlocks.length) {
      if (oldIdx >= oldBlocks.length) {
        container.appendChild(renderBlock(newBlocks[newIdx], function() { return 'diff-added'; }, resolvedMap,
          { commentable: true, blockIndex: newIdx, commentsMap: commentsMap }));
        newIdx++;
      } else if (newIdx >= newBlocks.length) {
        container.appendChild(renderBlock(oldBlocks[oldIdx], function() { return 'diff-removed'; }, null,
          { commentable: false, blockIndex: oldIdx }));
        oldIdx++;
      } else if (classifyBlock(oldBlocks[oldIdx], sets.added, sets.removed, 'old') === 'diff-removed') {
        container.appendChild(renderBlock(oldBlocks[oldIdx], function() { return 'diff-removed'; }, null,
          { commentable: false, blockIndex: oldIdx }));
        oldIdx++;
      } else if (classifyBlock(newBlocks[newIdx], sets.added, sets.removed, 'new') === 'diff-added') {
        container.appendChild(renderBlock(newBlocks[newIdx], function() { return 'diff-added'; }, resolvedMap,
          { commentable: true, blockIndex: newIdx, commentsMap: commentsMap }));
        newIdx++;
      } else {
        // Both unchanged — emit newBlock once (no diff class), advance both
        container.appendChild(renderBlock(newBlocks[newIdx], null, resolvedMap,
          { commentable: true, blockIndex: newIdx, commentsMap: commentsMap }));
        newIdx++;
        oldIdx++;
      }
    }

    const diffEl = document.getElementById('diffView');
    diffEl.innerHTML = '';
    diffEl.appendChild(container);
  }

  function setDiffActive(active) {
    diffActive = active;
    document.getElementById('diffToggle').classList.toggle('btn-active', active);
    const diffEl = document.getElementById('diffView');
    const docEl = document.getElementById('document');
    if (active) {
      document.getElementById('diffModeToggle').style.display = '';
      if (diffMode === 'split') renderDiffView();
      else renderUnifiedDiffView();
      diffEl.style.display = '';
      docEl.style.display = 'none';
    } else {
      document.getElementById('diffModeToggle').style.display = 'none';
      diffEl.style.display = 'none';
      docEl.style.display = '';
    }
  }

  function setDiffMode(mode) {
    localStorage.setItem('crit-diff-mode', mode);
    diffMode = mode;
    document.getElementById('diffModeSplit').classList.toggle('btn-active', mode === 'split');
    document.getElementById('diffModeUnified').classList.toggle('btn-active', mode === 'unified');
    if (diffActive) {
      if (mode === 'split') renderDiffView();
      else renderUnifiedDiffView();
    }
  }

  document.getElementById('diffToggle').addEventListener('click', function() {
    setDiffActive(!diffActive);
  });

  document.getElementById('diffModeSplit').addEventListener('click', () => setDiffMode('split'));
  document.getElementById('diffModeUnified').addEventListener('click', () => setDiffMode('unified'));
  (function() {
    const saved = localStorage.getItem('crit-diff-mode');
    if (saved === 'split' || saved === 'unified') {
      setDiffMode(saved);
    } else {
      setDiffMode(window.innerWidth < 1200 ? 'unified' : 'split');
    }
  })();

  // ===== Keyboard Shortcuts =====
  function toggleShortcutsOverlay() {
    document.getElementById('shortcutsOverlay').classList.toggle('active');
  }

  document.getElementById('shortcutsToggle').addEventListener('click', toggleShortcutsOverlay);
  document.getElementById('shortcutsOverlay').addEventListener('click', function(e) {
    if (e.target === this) toggleShortcutsOverlay();
  });

  function getCommentsForFocusedBlock() {
    if (focusedBlockIndex === null || focusedBlockIndex >= lineBlocks.length) return [];
    const block = lineBlocks[focusedBlockIndex];
    return comments.filter(function(c) {
      return c.end_line >= block.startLine && c.end_line <= block.endLine;
    });
  }

  function scrollFocusedBlockIntoView() {
    const el = document.querySelector('.line-block.focused');
    if (el) el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }

  document.addEventListener('keydown', function(e) {
    // Don't fire shortcuts when typing in inputs
    const tag = document.activeElement.tagName;
    if (tag === 'TEXTAREA' || tag === 'INPUT' || document.activeElement.isContentEditable) {
      // But still handle Escape to cancel comment form
      if (e.key === 'Escape') {
        if (activeForm) {
          e.preventDefault();
          cancelComment();
        }
      }
      return;
    }

    // Handle shortcuts overlay dismiss
    if (document.getElementById('shortcutsOverlay').classList.contains('active')) {
      if (e.key === 'Escape' || e.key === '?') {
        e.preventDefault();
        toggleShortcutsOverlay();
      }
      return;
    }

    // Let browser handle modifier combos (Cmd+F, Ctrl+C, etc.)
    if (e.metaKey || e.ctrlKey || e.altKey) return;

    switch (e.key) {
      case 'j': {
        e.preventDefault();
        if (lineBlocks.length === 0) return;
        if (focusedBlockIndex === null) {
          focusedBlockIndex = 0;
        } else if (focusedBlockIndex < lineBlocks.length - 1) {
          focusedBlockIndex++;
        }
        renderDocument();
        scrollFocusedBlockIntoView();
        break;
      }
      case 'k': {
        e.preventDefault();
        if (lineBlocks.length === 0) return;
        if (focusedBlockIndex === null) {
          focusedBlockIndex = 0;
        } else if (focusedBlockIndex > 0) {
          focusedBlockIndex--;
        }
        renderDocument();
        scrollFocusedBlockIntoView();
        break;
      }
      case 'c': {
        e.preventDefault();
        if (focusedBlockIndex === null) return;
        const block = lineBlocks[focusedBlockIndex];
        selectionStart = block.startLine;
        selectionEnd = block.endLine;
        activeForm = {
          afterBlockIndex: focusedBlockIndex,
          startLine: block.startLine,
          endLine: block.endLine,
          editingId: null
        };
        renderDocument();
        focusCommentTextarea();
        break;
      }
      case 'e': {
        e.preventDefault();
        const eComments = getCommentsForFocusedBlock();
        if (eComments.length === 0) return;
        editComment(eComments[0]);
        break;
      }
      case 'd': {
        e.preventDefault();
        const dComments = getCommentsForFocusedBlock();
        if (dComments.length === 0) return;
        // Show inline delete confirmation on the focused block
        const focusedEl = document.querySelector('.line-block.focused');
        if (!focusedEl || focusedEl.querySelector('.delete-confirm')) return;
        const confirm = document.createElement('div');
        confirm.className = 'delete-confirm';
        confirm.style.cssText = 'position:absolute;top:0;right:8px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:4px;padding:4px 8px;font-size:12px;color:var(--fg-secondary);z-index:10;display:flex;align-items:center;gap:6px;';
        confirm.innerHTML = 'Delete? <kbd style="background:var(--bg-hover);border:1px solid var(--border);border-radius:3px;padding:0 4px;font-family:var(--font-mono);font-size:11px;cursor:pointer;">y</kbd> <kbd style="background:var(--bg-hover);border:1px solid var(--border);border-radius:3px;padding:0 4px;font-family:var(--font-mono);font-size:11px;cursor:pointer;">n</kbd>';
        focusedEl.appendChild(confirm);
        function handleDeleteConfirm(ev) {
          if (ev.key === 'y') {
            ev.preventDefault();
            deleteComment(dComments[0].id);
          }
          if (ev.key === 'y' || ev.key === 'n' || ev.key === 'Escape') {
            ev.preventDefault();
            confirm.remove();
            document.removeEventListener('keydown', handleDeleteConfirm, true);
          }
        }
        document.addEventListener('keydown', handleDeleteConfirm, true);
        break;
      }
      case 'F': {
        e.preventDefault();
        if (uiState !== 'reviewing') return;
        document.getElementById('finishBtn').click();
        break;
      }
      case 't': {
        e.preventDefault();
        document.getElementById('tocToggle').click();
        break;
      }
      case '?': {
        e.preventDefault();
        toggleShortcutsOverlay();
        break;
      }
      case 'Escape': {
        e.preventDefault();
        if (activeForm) {
          cancelComment();
        } else if (selectionStart !== null) {
          selectionStart = null;
          selectionEnd = null;
          renderDocument();
        } else if (focusedBlockIndex !== null) {
          focusedBlockIndex = null;
          renderDocument();
        }
        break;
      }
    }
  });

  // ===== Start =====
  init();
  connectSSE();

})();
</script>
</body>
</html>
